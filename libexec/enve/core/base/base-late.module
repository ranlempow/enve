#!/bin/sh

# shellcheck source=libexec/enve/base
. "$ENVE_HOME/enve/base"

# shellcheck source=libexec/enve/envelib
. "$ENVE_HOME/enve/envelib"

# shellcheck source=libexec/enve/findutils
. "$ENVE_HOME/enve/findutils"


settrace


resolve_basic_late() {
    [ -n "$TABLE" ] && echo "$TABLE"

    # fast_table_tail "layout\\.root"
    # root=${TABLE_TAIL:-$PWD}
    # root=${root%/}

    { table_subset "path" || true; } | as_value | \
    while read -r value; do
        if [ "${value#${value%?}}" != '$' ]; then
            d=$value
            fast_resolve_path
            value=$d
            # if [ "${value%"${value#?}"}" != '/' ]; then
            #     value="$root/$value"
            # fi
            # value="$(resolve_path "$value")"
        fi
        out_list PATH "$value"
    done

    { table_subset "passvar" || true; } | as_value | \
    while read -r value; do
        out_list BYPASS "$value"
    done
    out_list BYPASS "PRJ_NAME"
    out_list BYPASS "TERMTHEME"
    out_list BYPASS "ENVE_CACHED_OS"

    fast_get_system
    out_var "ENVE_CACHED_OS" "$ENVE_CACHED_OS"

    out_list BYPASS "TERM"
    out_list BYPASS "TMUX"
    # out_list BYPASS "SHELL"

    { table_subset "dotfiles" || true; } | as_value | \
    while read -r value; do
        cnt=$((${cnt:-0} + 1))
        out_source "dot${cnt}" "$(resolve_path "$value")"
    done

    { table_subset "alias\\..*" || true; } | as_postfix "alias\\." | \
    while read -r name value; do
        eval out_alias "$name" "$value"
    done

    # this is for unicode character in console
    out_var "LC_ALL" "en_US.UTF-8"
    out_var "LANG" "en_US.UTF-8"

    fast_table_tail "layout\\.root"
    PRJROOT=$TABLE_TAIL

    fast_table_tail "exec\\.cwd"
    cwd=${TABLE_TAIL:-%cwd}
    if [ "$cwd" = "%cwd" ]; then
        :
    elif [ "${cwd%"${cwd#?????}"}" = "%root" ] && [ -n "$PRJROOT" ]; then
        out_code sh 'cd "'"$PRJROOT${cwd#\%root}"'"'
    else
        out_code sh 'cd "'"$cwd"'"'
    fi
}

resolve_command() {
    [ -n "$TABLE" ] && echo "$TABLE"

    if [ -n "$(table_subset "cmd\\..*" | as_concat ' ' || true)" ]; then
        TDIR="$(mktemp -d)"
        mkdir "$TDIR/cmd"
        { table_subset "cmd\\..*" || true; } | as_postfix "cmd\\." | \
        while read -r name value; do
            # out_var "$name" "$value"
            echo "$value" > "$TDIR/cmd/$name"
            chmod 555 "$TDIR/cmd/$name"
        done
        out_list PATH "$TDIR/cmd"
    fi
}


# resolve_terminal() {
#     [ -n "$TABLE" ] && echo "$TABLE"
#     if [ "$(table_tail "core\\.target")" = "shell" ]; then
#         size=$(table_tail "terminal.size")
#         if [ -n "$size" ]; then
#             out_var TERMSIZE "$size"
#         fi
#         theme=$(table_tail "terminal.theme")
#         if [ -n "$theme" ]; then
#             out_var TERMTHEME "$theme"
#         fi
#     fi
# }



resolve_prompt() {
    [ -n "$TABLE" ] && echo "$TABLE"

    target="$(table_tail "core\\.target")"
    if  [ "$target" = "shell" ]; then
        if  [ "$(table_tail "shell")" = "bash" ]; then

            ENV_ROOT="$(table_tail ENV_ROOT)"
            for script in "$ENV_ROOT"/etc/bash_completion.d/*; do
                if [ "${script#"${script%?}"}" != '*' ]; then
                    out_source "$(basename "${script%.*}")" "$script"
                fi
            done
            if [ -f "$ENV_ROOT/share/bash-completion/bash_completion" ]; then
                out_source bash_completion "$ENV_ROOT/share/bash-completion/bash_completion"
            fi
            out_alias ls 'ls --color'
            out_list ENVE_BASHOPTS checkwinsize
        fi
    fi
}



resolve_secret() {
    #
    # keys:
    #   secret.variable
    #

    [ -n "$TABLE" ] && echo "$TABLE"
    { table_subset "secret\\.variable\\..*" || true; } | as_postfix "secret\\.variable\\." | \
    while read -r name value; do
        out_secret "$name" "$value"
    done
}


resolve_boundfiles() {
    # TODO: 與gitignore整合, 並且考慮enve.bound.ignore
    # 整個專案資料夾的所有檔案都理論上都是bound
    # 當bound沒有依賴專案資料夾以外的檔案, 而且所有的submodule也都是pure bound
    #   而且使用者沒有設定enve.bound.pure, 則此 enve.bound.pure=true
    # ignore順序
    # 1. +all
    # 2. include .gitignore
    # 3. +enve.bound
    # 4. include enve.bound.ignore

    fast_table_tail "layout\\.root"
    PRJROOT=$TABLE_TAIL
    if [ -n "$PRJROOT" ] ; then
        # PRJROOT="$(resolve_path "$(table_tail "layout\\.root")")"
        # if [ -z "$PRJROOT" ]; then
        #     error "layout.root not defiend"
        #     return 1
        # fi

        bounds=
        # PRJROOT must be abspath
        PRJROOT=${PRJROOT%/}
        # _clock 'bound1'
        fast_table_tail "enve\\.nobound"
        if [ "$TABLE_TAIL" != "true" ]; then
            # bounds=$(useprint=1 fileonly=1 recursive=1 listdir "$PRJROOT")
            bounds=$(find "$PRJROOT" ! -type d)
        fi

        # _clock 'bound2'
        # if table_subset "enve\\.bound"; then
        #     bounds="$bounds${bounds:+$newl}$(table_subset "enve\\.bound" | as_concat "$newl" || true)"
        usegrep=1 fast_table_subset "enve\\.bound"
        # _clock 'bound2.1'
        if [ -n "$TABLE_SUBSET" ]; then
            fast_as_value
            # fast_as_concat "$newl"
            # _clock 'bound2.2'
            _bounds=
            while read -r path; do
                case $path in
                    ./*)    _bounds="${_bounds}$PRJROOT/${path#??}$newl";;
                    /*)     _bounds="${_bounds}$path$newl";;
                    ?*)     _bounds="${_bounds}$PRJROOT/$path$newl";;
                esac
            done<<EOF
$TABLE_AS
EOF
            bounds="${bounds}${_bounds}"
            unset _bounds
        fi

        # _clock 'bound3'
        # TODO:
        #  1. determine gitroot=(git rootdir or PRJROOT)
        #  2. apply all .gitignore in gitroot
        #  3. plus "enve\\.bound\\.ignore" in a oneshot

        if [ -f "$PRJROOT/.gitignore" ]; then
            bounds="$(echo "$bounds" | gitignore_filter "$(cat "$PRJROOT/.gitignore")" )"
        fi

        # _clock 'bound4'
        fast_table_subset "enve\\.bound\\.ignore"
        if [ -n "$TABLE_SUBSET" ]; then
            fast_as_value
            # fast_as_concat "$newl"
            bounds="$(echo "$bounds" | gitignore_filter "$TABLE_AS")"
        fi
        # bounds="$(echo "$bounds" | gitignore_filter "$(table_subset "enve\\.bound\\.ignore" | as_concat "$newl" || true)" )"
        # echo "== BOUND:" >&2
        # echo "$bounds" >&2

        # _clock 'bound5'
        BOUND_TABLE=
        while read -r path; do
            if [ -n "$path" ]; then
                # out_var_just bound "$path"
                BOUND_TABLE="${BOUND_TABLE}VAR${tab}bound${tab}$path$newl"
            fi
        done<<EOF
$bounds
EOF
        TABLE="${TABLE%%$newl}${TABLE:+$newl}$BOUND_TABLE"
        # _clock 'bound6'
    fi

    [ -n "$TABLE" ] && echo "$TABLE"
}


resolve_bypass() {
    [ -n "$TABLE" ] && echo "$TABLE"
    fast_table_subset "BYPASS" "LIST"
    fast_as_concat ":"
    out_raw_fast "BYPASS" "$TABLE_AS" META

    fast_table_tail "core\\.target"
    out_raw_fast "target" "$TABLE_TAIL" META
}

main() {
    info "IN $ZERO/base-late.module"
    TABLE=$(cat "${configfile:--}")
    for proc in basic_late command prompt secret boundfiles bypass; do
        info "IN resolve_$proc"
        if ! TABLE=$(TABLE=$TABLE resolve_$proc); then
            _error "error at resolve_$proc"
            exit 1
        fi
        # info "OUT resolve_$proc"
    done
    info "OUT $ZERO/base-late.module"
    [ -n "$TABLE" ] && echo "$TABLE"
}
