#!/bin/sh

# shellcheck source=libexec/enve/base
. "$ENVE_HOME/enve/base"

# shellcheck source=libexec/enve/envelib
. "$ENVE_HOME/enve/envelib"

settrace

# x='
# config.clearEnv
# config.shell
# layout.root
# layout.var
# path
# passvar
# variable
# command
# require.python.pipfile
# require.node.npmfile
# require.ruby.gemfile
# import
# module
# '

resolve_first() {
    [ -n "$TABLE" ] && echo "$TABLE"
    out_var HOME "$HOME"
    out_var USER "$USER"
    # out_var TERM "$TERM"
    out_var TMPDIR "${TMPDIR:-/tmp}"
}

resolve_basic() {
    [ -n "$TABLE" ] && echo "$TABLE"
    # if [ "${1:-}" != "--as_module" ]; then
    #     PRJROOT="$(resolve_path "$(table_tail "layout\\.root")")"
    #     PRJVAR="$(resolve_path "$(table_tail "layout\\.var")")"
    # fi

    { table_subset "path" || true; } | as_value | \
    while read -r value; do
        if [ "${value#${value%?}}" != '$' ]; then
            value="$(resolve_path "$value")"
        fi
        out_list PATH "$value"
    done

    out_join BYPASS ':'
    { table_subset "passvar" || true; } | as_value | \
    while read -r value; do
        out_list BYPASS "$value"
    done
    out_list BYPASS "PRJ_NAME"
    out_list BYPASS "TERMTHEME"

    out_list BYPASS "TERM"
    out_list BYPASS "TMUX"
    # out_list BYPASS "SHELL"

    { table_subset "dotfiles" || true; } | as_value | \
    while read -r value; do
        cnt=$((${cnt:-0} + 1))
        out_source "dot${cnt}" "$(resolve_path "$value")"
    done

    { table_subset "alias\\..*" || true; } | as_postfix "alias\\." | \
    while read -r name value; do
        eval out_alias "$name" "$value"
    done

    { table_subset "variable\\..*" || true; } | as_postfix "variable\\." | \
    while read -r name value; do
        out_var "$name" "$value"
    done
    config_filename=$(table_tail "enve\\.configs")
    if [ "${config_filename%.enve.ini}" != "$config_filename" ]; then
        name=$(basename "$config_filename")
        PRJ_NAME=${name%.enve.ini}
    else
        PRJ_NAME=$(basename "$(dirname "$(resolve_path '.')")")
    fi
    out_var "PRJ_NAME" "$PRJ_NAME"


    # this is for unicode character in console
    out_var "LC_ALL" "en_US.UTF-8"
    out_var "LANG" "en_US.UTF-8"

    # out_var "ENVE_PREV_PRJ_NAME" "${PRJ_NAME:-}"
}

resolve_command() {
    [ -n "$TABLE" ] && echo "$TABLE"

    if [ -n "$(table_subset "cmd\\..*" | as_concat ' ' || true)" ]; then
        TDIR="$(mktemp -d)"
        mkdir "$TDIR/cmd"
        { table_subset "cmd\\..*" || true; } | as_postfix "cmd\\." | \
        while read -r name value; do
            # out_var "$name" "$value"
            echo "$value" > "$TDIR/cmd/$name"
            chmod 555 "$TDIR/cmd/$name"
        done
        out_list PATH "$TDIR/cmd"
    fi
}

resolve_terminal() {
    [ -n "$TABLE" ] && echo "$TABLE"
    if [ "$(table_tail "core\\.target")" = "shell" ]; then
        size=$(table_tail "terminal.size")
        if [ -n "$size" ]; then
            out_var TERMSIZE "$size"
        fi
        theme=$(table_tail "terminal.theme")
        if [ -n "$theme" ]; then
            out_var TERMTHEME "$theme"
        fi
    fi
}



resolve_prompt() {
    [ -n "$TABLE" ] && echo "$TABLE"

    if  [ "$(table_tail "core\\.target")" = "shell" ] && \
        [ "$(table_tail "shell")" != "zsh" ]; then

        ENV_ROOT="$(table_tail ENV_ROOT)"
        # echo "ENV_ROOT:$ENV_ROOT">&2
        for script in "$ENV_ROOT"/etc/bash_completion.d/*; do
            out_source "$(basename "${script%.*}")" "$script"
        done
        # export GIT_PS1_SHOWCOLORHINTS='true'
        # out_var GIT_PS1_SHOWCOLORHINTS 'true'
        # export PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
        # export PROMPT_COMMAND='__git_ps1  "\u@\h:\w"  "\$ "  " (%s)"'

        # shellcheck disable=2016
        # out_rawvar PROMPT_COMMAND '__git_ps1  "\u:\w [\[\033[36m\]${PRJ_NAME}\[\033[m\]]"  " \$ "  " (%s)"'
        # out_var PROMPT_COMMAND '__git_ps1  "\u:\w [\[\033[36m\]\${PRJ_NAME}\[\033[m\]]"  " \$ "  " (%s)"'

        # export LANG="zh_TW.UTF-8"
        # export PS1="\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "

        # [[ $PS1 && -f "$ENV_ROOT/share/bash-completion/bash_completion" ]] && \
        if [ -f "$ENV_ROOT/share/bash-completion/bash_completion" ]; then
            out_source bash_completion "$ENV_ROOT/share/bash-completion/bash_completion"
        fi
        out_alias ls 'ls --color'
        # alias ls="ls --color"
        out_join ENVE_BASHOPTS ':'
        out_join ENVE_SHELLOPTS ':'
        out_list ENVE_BASHOPTS checkwinsize
        # out_list ENVE_BASHOPTS autocd
    fi
}

resolve_nix() {
    given_shell=$(table_tail "shell")
    if [ "$(table_tail "enve\\.no_nix")" = "true" ]; then
        if [ -n "$given_shell" ]; then
            out_var SHELL "$(command -v $given_shell)"
        else
            out_var SHELL "$SHELL"
        fi
        [ -n "$TABLE" ] && echo "$TABLE"
        # echo OUT nix >&2
        return
    fi
    PRJ_NAME="$(table_tail "PRJ_NAME")"

    nix_channel_url="$(table_tail "nix\\.channel\\.url")"
    # nix_channel_sha256="$(table_tail nix.channel.sha256)"

    if [ -z "${nix_channel_url:-}" ]; then
        nix_channel_version="$(table_tail nix.channel.version)"
        if [ -n "$nix_channel_version" ]; then
            nix_channel_url="https://github.com/NixOS/nixpkgs/archive/$nix_channel_version.tar.gz"
        else
            # nix_channel_url="https://github.com/NixOS/nixpkgs/archive/17.09.tar.gz"
            nix_channel_url="https://github.com/NixOS/nixpkgs/archive/18.09.tar.gz"
        fi
        # nix_channel_sha256="405f1d6ba523630c83fbabef93f0da11ea388510a576adf2ded26a744fbf793e"
    fi


    pkgs="$(table_subset "nix\\.require" | as_concat ' ')"
    pkgs="$pkgs $(table_subset "nix\\.packages" | as_concat ' ')"

    # echo "pkgs: $pkgs" >&2
    LOGTYPE=nix _info "pkgs: $pkgs"
    nix_root="$(resolve_path "$(table_tail "nix\\.root")")"
    nix_root=${nix_root:-/nix/var/nix/profiles/default}
    # if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
    #   . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
    # fi

    # echo "$(table_subset "nix\\.files")" >&2
    nix_extra=
    for file in $(table_subset "nix\\.files" | as_value); do
        absfile="$(resolve_path "$file")"
        nix_extra="${nix_extra}${newl}$(cat "$absfile")"
    done
    if [ -n "$nix_extra" ]; then
        LOGLEVEL=DEBUG log "==== NIX_EXTRA ===="
        LOGLEVEL=DEBUG log "$nix_extra"
    fi

    nix_config="$(
        { table_subset "nix.config\\..*"; } | as_postfix "nix.config\\." | \
        while read -r name value; do
            if [ -n "$name" ]; then
                echo "$name = $value;"
            fi
        done
    )"




    # install nix, if /nix not in system
    if [ ! -d /nix ]; then
        {
            echo "warning: nix is not installed on this system."
            echo ""
            echo "you should prepare the essential tools that required by enve."
            echo "those tools includes bash, curl, shasum, md5sum, tar, mktemp, maybe more"
            echo "and all tools in posix definition."
            echo "we recommand install nix as soon as possible with:"
            echo "    enve bootstrap"
        } >&2
        $ENVE_HOME/enve/script/install_nix.sh install >&2 || {
            _error "your system do not have nix installed, try install but failed"
            return 1
        }
    fi

    p_text() {
        printf %s\\n "v20190308v2"
        printf %s\\n "$nix_root"
        printf %s\\n "$nix_channel_url"
        printf %s\\n "$nix_config"
        printf %s\\n "$nix_extra"
        printf %s\\n "$PRJ_NAME"
        printf %s\\n "$pkgs"
    }

    p_make() {
        # TODO: I remove openssl_1_1_0 at pkgs, maybe need add back?
        # TODO: add findutils back
        if env_root="$(
            NIX_REMOTE=daemon \
            NIX_SSL_CERT_FILE=/nix/var/nix/profiles/default/etc/ssl/certs/ca-bundle.crt \
            NIXPKGS_ALLOW_UNFREE=1 \
        "$nix_root"/bin/nix-build --no-out-link --show-trace - <<EOF
        let
          pkgs = import (builtins.fetchTarball {
            url = $nix_channel_url;
          }) { config = { $nix_config }; };
          $nix_extra
        in
          pkgs.buildEnv {
            name = "${PRJ_NAME:-}${PRJ_NAME:+-}env";
            paths = with pkgs; [
              coreutils diffutils which file
              gnused gnugrep gawkInteractive gnutar gzip bzip2 less gettext
              git gnupatch
              xz unzip
              bashInteractive bashCompletion
              time rsync
              $pkgs
            ];
          }
EOF
        )"; then
            echo "$env_root" > "$CACHED/env_root"
        else
            return 1
        fi
    }
    catalog=nix-env cache_path ./env_root p_text p_make
    fast_readtext $cached_path
    env_root=$text

    LOGTYPE=nix _info "env_root: $env_root"

    out_var ENV_ROOT "$env_root"
    if [ -n "$given_shell" ]; then
        out_var SHELL "$env_root/bin/$given_shell"
    else
        out_var SHELL "$env_root/bin/bash"
    fi
    [ -n "$TABLE" ] && echo "$TABLE"
    [ -n "${env_root:-}" ] && out_list PATH "$env_root/bin"
}

resolve_macos() {
    out_join PATH ':'
    [ -n "$TABLE" ] && echo "$TABLE"
    (
        # shellcheck disable=2123
        PATH=
        export PATH
        eval "$(/usr/libexec/path_helper -s)"
        IFS=':'
        for p in $PATH; do
            out_list PATH "$p"
        done
    )

    # if [ -n "${SSH_AUTH_SOCK:-}" ]; then
    #     out_var SSH_AUTH_SOCK "$SSH_AUTH_SOCK"
    # fi
    out_var enve.bound.ignore '**/.DS_Store'
    out_var enve.bound.ignore '**/.git/**'

    out_list BYPASS "SSH_AUTH_SOCK"
    out_list BYPASS "TERMINFO"
    out_list BYPASS "KITTY_WINDOW_ID"
    out_list BYPASS "COLORTERM"

    # out_var LC_ALL "en_US.UTF-8"
    # out_var LC_CTYPE "en_US.UTF-8"
    # out_var LANG "en_US.UTF-8"
    # out_var PYTHONIOENCODING "utf-8:surrogateescape"

}

resolve_ssh() {
    [ -n "$TABLE" ] && echo "$TABLE"
    out_list BYPASS "SSH_CONNECTION"
    out_list BYPASS "SSH_TTY"
    out_list BYPASS "SSH_CLIENT"
    # if SSH_CONNECTION define, terminal is using ssh

}

resolve_shell() {
    [ -n "$TABLE" ] && echo "$TABLE"
    out_var "ENVE_SHELLOPTS" "$(table_subset "shell\\.set" | as_concat ":" || true)"
    out_var "ENVE_BASHOPTS" "$(table_subset "shell\\.shopt" | as_concat ":" || true)"
    out_var "ENVE_ZSHOPTS" "$(table_subset "shell\\.setopt" | as_concat ":" || true)"
    # given_shell=$(table_tail "shell")
    # if [ -n "$given_shell" ]; then
    #     out_var SHELL "$given_shell"
    # fi
}

resolve_secret() {
    #
    # keys:
    #   secret.variable
    #

    [ -n "$TABLE" ] && echo "$TABLE"
    { table_subset "secret\\.variable\\..*" || true; } | as_postfix "secret\\.variable\\." | \
    while read -r name value; do
        out_sec "$name" "$value"
    done
}

resolve_boundfiles() {
    # TODO: 與gitignore整合, 並且考慮enve.bound.ignore
    # 整個專案資料夾的所有檔案都理論上都是bound
    # 當bound沒有依賴專案資料夾以外的檔案, 而且所有的submodule也都是pure bound
    #   而且使用者沒有設定enve.bound.pure, 則此 enve.bound.pure=true
    # ignore順序
    # 1. +all
    # 2. include .gitignore
    # 3. +enve.bound
    # 4. include enve.bound.ignore

    # TODO: PRJROOT must be abspath
    PRJROOT="$(resolve_path "$(table_tail "layout\\.root")")"

    bounds="$(cd "$PRJROOT"; find . ! -type d)"

    if [ -f "$PRJROOT/.gitignore" ]; then
        bounds="$(echo "$bounds" | gitignore_filter "$(cat "$PRJROOT/.gitignore")" )"
    fi
    if table_subset "enve\\.bound"; then
        bounds="$bounds${bounds:+$newl}$(table_subset "enve\\.bound" | as_concat "$newl" || true)"
    fi
    bounds="$(echo "$bounds" | gitignore_filter "$(table_subset "enve\\.bound\\.ignore" | as_concat "$newl" || true)" )"
    # echo "== BOUND:" >&2
    # echo "$bounds" >&2

    bounds_table="$(
        cd "$PRJROOT"
        while read -r path; do
            if [ -n "$path" ]; then
                out_var bound "$(resolve_symlinks "$path")"
            fi
        done <<EOF
$bounds
EOF
    )"

    [ -n "$TABLE" ] && echo "$TABLE"
    echo "$bounds_table"
}

main() {
    info "IN $(basename $ZERO)/enve.module"
    TABLE=$(cat "${configfile:--}")
    for proc in first basic command nix terminal prompt macos ssh \
                shell secret boundfiles; do

        info "IN resolve_$proc"
        if ! TABLE=$(TABLE=$TABLE resolve_$proc); then
            _error "error at resolve_$proc"
            exit 1
        fi
        # info "OUT resolve_$proc"
    done

    info "OUT $(basename $ZERO)/enve.module"
    [ -n "$TABLE" ] && echo "$TABLE"
}

# if [ "${TEST:-}" != "test" ]; then
# fi

