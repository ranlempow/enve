#!/bin/sh

# shellcheck source=libexec/enve/base
. "$ENVE_HOME/enve/base"

settrace


# _install_config() {
#     path=$1
#     template=$2
#     if [ -e "$path" ] ; then
#         fast_readtext "$path"
#         existing_text=$text
#         fast_readtext "$template"
#         if [ "$text" != "$existing_text" ]; then
#             mv "$path" "$path.bak.1"
#             # i=1
#             # while ! mv "$path" "$path.bak.$i"; do
#             #     i=$((i+1))
#             #     if [ "$i" -gt 100 ]; then
#             #         return 1
#             #     fi
#             # done
#             cp "$template" "$path"
#             _info "create $path"
#         fi
#     else
#         cp "$template" "$path"
#         _info "create $path"
#     fi
# }

# TODO: move to core/term
# terminal_config() {
#     _install_config ~/.tmux.conf "$ZERO/../term/tmux.conf"
#     _install_config ~/.inputrc "$ZERO/../term/inputrc"
#     if [ -d ~/.config/kitty ] ; then
#         _install_config ~/.config/kitty/kitty.conf "$ZERO/../term/kitty.conf"
#         _install_config ~/.config/kitty/macos-launch-services-cmdline "$ZERO/../term/kitty.macos-launch-services-cmdline"
#     fi
# }


# eval_secret() {
#     deftext=$bypass_envs
#     # if [ -n "${invoke_bypass:-}" ]; then
#     #     OLDIFS=$IFS; IFS=':'
#     #     for var in $invoke_bypass; do
#     #         var=$var fast_append_variable_quote
#     #     done
#     #     IFS=$OLDIFS
#     # fi
#     # bypass_envs=$deftext
#     # bypass_envs=${bypass_envs%% }
# }


tmux_launch() {
    target_name=$1
    # background=${2:-}
    shift 1

    all_nums=" "
    min_unattached=-1
    while read -r session_name session_attached; do
        if [ -n "$session_name" ]; then
            name=${session_name%%[0123456789]}
            if [ "${name#${name%?}}" = "-" ]; then
                num=${session_name#"${name}-"}
                name=${session_name%"-$num"}
            else
                num=0
                name=${session_name}
            fi
            if [ "$target_name" = "$session_name" ]; then
                all_nums="${all_nums}$num "
                if [ "$session_attached" -eq 0 ] && [ "$min_unattached" -gt "$num" ]; then
                    min_unattached=$num
                fi
            fi
        fi
    done <<EOF
$(tmux list-sessions -F '#session_name #session_attached')
EOF

    if [ "$min_unattached" -gt -1 ]; then
        if [ "$min_unattached" -eq 0 ]; then
            sname="${target_name}"
        else
            sname="${target_name}-$min_unattached"
        fi
        tmux -2u attach-session -t "$sname"
    else
        # create new if all session is attached
        min_nonexist=0
        while [ "${all_nums#" $min_nonexist "*}" != "$all_nums" ]; do
            s=$all_nums
            replace " $min_nonexist " ""
            all_nums=$s
            min_nonexist=$((min_nonexist + 1))
        done
        if [ "$min_nonexist" -eq 0 ]; then
            sname="${target_name}"
        else
            sname="${target_name}-$min_nonexist"
        fi
        # create new
        tmux -2u new-session ${background:+-d} -s "$sname" "$@"
    fi
}


make_run_cmdline() {
    ephemeral=$(mkstemp ${TMPDIR:-/tmp}/ephemeral-$PRJ_NAME.XXXXXX)
    echo "rm \$0; . $RCFILE_PATH \"\$@\";" > $ephemeral
    eval_shell="env -i $bypass_envs sh \"$ephemeral\" \"\$@\""
}

make_module_cmdline() {
    eval_shell="sh \"\$RCFILE_PATH\" \"\$@\""
}


make_shell_cmdline() {
    shell=${invoke_shell:-$SHELL}

    # posix mode
    # ENV=$PWD/e zsh -c 'exec -a sh zsh "$@"' "$@"
    # ENV=$PWD/e bash --posix
    # ksh/bash POSIXLY_CORRECT=YES

    d=$shell
    fast_basename
    shell_base=$d

    case $shell_base in
        dash|ash|ksh|sh)
                rc_arg=
                rc_env=ENV=\'$RCFILE_PATH\'
            ;;
        zsh)
                d=$RCFILE_PATH
                fast_dirname
                ZDOTDIR=$d
                if [ ! -f "$ZDOTDIR/.zshrc" ]; then
                    ln -s "$RCFILE_PATH" "$ZDOTDIR/.zshrc"
                fi
                rc_arg=
                rc_env=ZDOTDIR=\'$ZDOTDIR\'
            ;;
        bash)
                # rc_arg=--rcfile

                # use bash posix mode to prevent expose secret at commandline
                rc_env=ENV=\'$RCFILE_PATH\'
                rc_arg=
                mark_args="--rcfile $PRJ_NAME"
                ext_args="--posix $mark_args"
            ;;
        *)
                die "unsuported shell $shell"
            ;;
    esac
    eval_shell="\
env -i $bypass_envs${rc_env:+" $rc_env"} \
'$shell'${rc_arg:+" $rc_arg '$RCFILE_PATH'"}${ext_args:+ $ext_args} -i\
"
    LOGTYPE="eval" _trace "$eval_shell"
}



case $target in
    shell)
            make_shell_cmdline
            eval exec "$eval_shell"
        ;;
    run)
            # args=$(save "$@")
            # eval exec env -i "$bypass_envs" sh \"\$RCFILE_PATH\" "$args"
            # ephemeral=$(mkstemp ${TMPDIR:-/tmp}/ephemeral-$PRJ_NAME.XXXXXX)
            # echo "rm \$0; . $RCFILE_PATH \"\$@\";" > $ephemeral
            # eval exec env -i "$bypass_envs" sh $ephemeral \"\$@\"
            make_run_cmdline
            eval exec "$eval_shell"
        ;;
    loader|module)
            # echo "RUN_MOD: $@"
            # exec sh "$RCFILE_PATH" "$@"
            make_module_cmdline
            eval exec "$eval_shell"
        ;;
    terminal)
        case ${invoke_termainal:-native} in
            native)
                    make_shell_cmdline
                    eval exec "$ENVE_HOME/enve/core/macos/term.applescript" "\"exec $eval_shell\""
                ;;
            kitty)
                    if [ ! -e /Applications/kitty.app ]; then
                        # shellcheck source=libexec/enve/bootlib
                        . "$ENVE_HOME/enve/bootlib"
                        ensure_brew
                        brew cask install kitty
                    fi
                    make_shell_cmdline
                    #  --config <CONFIG>, -c <CONFIG>
                    #  --override <OVERRIDE>, -o <OVERRIDE>

                    # shellcheck disable=2009
                    if ps -Al | grep "[Kk]itty" >/dev/null 2>&1; then
                        open -a /Applications/kitty.app
                        kitty=/Applications/kitty.app/Contents/MacOS/kitty
                        eval $kitty --single-instance /bin/sh -c "\"exec $eval_shell\""
                    else
                        echo "kitty --single-instance /bin/sh -c \"exec $eval_shell\"" \
                                > ~/.config/kitty/macos-launch-services-cmdline
                        open -a /Applications/kitty.app
                        echo "kitty --single-instance" > \
                                ~/.config/kitty/macos-launch-services-cmdline
                    fi
                ;;
            conemu)
                    make_shell_cmdline
                    case ${MSYSTEM:-MSYS} in
                        CYGWIN)
                                comenu_executor=$CONEMU_BASE/ConEmu/conemu-cygwin-64.exe
                            ;;
                        MSYS|MINGW32|MINGW64)
                                comenu_executor=$CONEMU_BASE/ConEmu/conemu-msys2-64.exe
                            ;;
                    esac
                    cmd /c start "" "$CONEMU_BASE/ConEmu64.exe" -run "$comenu_executor" /usr/bin/sh -c "\"exec $eval_shell\""
                ;;
            mintty)
                    cmd /c start "" "$MSYS_BIN_PATH/mintty.exe" -c "%USERPROFILE%/.minttyrc" -- "$MSYS_BIN_PATH/sh" -c "\"exec $eval_shell\""
                ;;
        esac
        ;;
esac
