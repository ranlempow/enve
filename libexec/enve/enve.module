#!/bin/sh
#!/usr/bin/env bash

# set -euo pipefail

# . "$1" define

# TODO: remove this
# if [ -z "${ENVE_HOME:-}" ]; then
#     ENVE_HOME="$(dirname $0)/.."
# fi


# shellcheck source=libexec/enve/base
. "$ENVE_HOME/enve/base"

# shellcheck source=libexec/enve/envelib
. "$ENVE_HOME/enve/envelib"

settrace

# x='
# config.clearEnv
# config.shell
# layout.root
# layout.var
# path
# passvar
# variable
# command
# require.python.pipfile
# require.node.npmfile
# require.ruby.gemfile
# import
# module
# '

resolve_first() {
    TABLE="$(cat "${configfile:--}")"
    echo IN first >&2
    echo "$TABLE"
    out_var HOME "$HOME"
    out_var USER "$USER"
    out_var TERM "$TERM"
    out_var TMPDIR "$TMPDIR"
    echo OUT first >&2
}

resolve_basic() {
    TABLE="$(cat "${configfile:--}")"
    echo IN basic >&2
    echo "$TABLE"
    # if [ "${1:-}" != "--as_module" ]; then
    #     PRJROOT="$(resolve_path "$(table_tail "layout\\.root")")"
    #     PRJVAR="$(resolve_path "$(table_tail "layout\\.var")")"
    # fi

    { table_subset "path" || true; } | as_value | \
    while read -r value; do
        if [ "${value#${value%?}}" != '$' ]; then
            value="$(resolve_path "$value")"
        fi
        out_list PATH "$value"
    done

    out_join BYPASS ':'
    { table_subset "passvar" || true; } | as_value | \
    while read -r value; do
        out_list BYPASS "$value"
    done
    out_list BYPASS "PRJ_NAME"
    out_list BYPASS "TERMTHEME"

    { table_subset "dotfiles" || true; } | as_value | \
    while read -r value; do
        cnt=$((${cnt:-0} + 1))
        out_source "dot${cnt}" "$(resolve_path "$value")"
    done

    { table_subset "alias\\..*" || true; } | as_postfix "alias\\." | \
    while read -r name value; do
        eval out_alias "$name" "$value"
    done

    { table_subset "variable\\..*" || true; } | as_postfix "variable\\." | \
    while read -r name value; do
        out_var "$name" "$value"
    done

    out_var "PRJ_NAME" "$(basename "$(dirname "$(resolve_path '.')")")"
    # out_var "ENVE_PREV_PRJ_NAME" "${PRJ_NAME:-}"
    echo OUT basic >&2
}

resolve_command() {
    TABLE="$(cat "${configfile:--}")"
    echo IN command >&2
    echo "$TABLE"

    if [ -n "$(table_subset "cmd\\..*" | as_concat ' ' || true)" ]; then
        TDIR="$(mktemp -d)"
        mkdir "$TDIR/cmd"
        { table_subset "cmd\\..*" || true; } | as_postfix "cmd\\." | \
        while read -r name value; do
            # out_var "$name" "$value"
            echo "$value" > "$TDIR/cmd/$name"
            chmod 555 "$TDIR/cmd/$name"
        done
        out_list PATH "$TDIR/cmd"
    fi
    echo OUT command >&2
}

resolve_terminal() {
    TABLE="$(cat "${configfile:--}")"
    echo IN terminal >&2
    echo "$TABLE"
    if [ "$(table_tail "core\\.target")" = "shell" ]; then
        size=$(table_tail "terminal.size")
        if [ -n "$size" ]; then
            out_var TERMSIZE "$size"
        fi
        theme=$(table_tail "terminal.theme")
        if [ -n "$theme" ]; then
            out_var TERMTHEME "$theme"
        fi
    fi
    echo OUT terminal >&2
}

resolve_prompt() {
    TABLE="$(cat "${configfile:--}")"
    echo IN prompt >&2
    echo "$TABLE"

    if [ "$(table_tail "core\\.target")" = "shell" ]; then
        ENV_ROOT="$(table_tail ENV_ROOT)"
        echo "ENV_ROOT:$ENV_ROOT">&2
        for script in "$ENV_ROOT"/etc/bash_completion.d/*; do
            out_source "$(basename "${script%.*}")" "$script"
        done
        # export GIT_PS1_SHOWCOLORHINTS='true'
        out_var GIT_PS1_SHOWCOLORHINTS 'true'
        # export PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
        # export PROMPT_COMMAND='__git_ps1  "\u@\h:\w"  "\$ "  " (%s)"'

        # shellcheck disable=2016
        # out_rawvar PROMPT_COMMAND '__git_ps1  "\u:\w [\[\033[36m\]${PRJ_NAME}\[\033[m\]]"  " \$ "  " (%s)"'
        out_var PROMPT_COMMAND '__git_ps1  "\u:\w [\[\033[36m\]${PRJ_NAME}\[\033[m\]]"  " \$ "  " (%s)"'

        # export LANG="zh_TW.UTF-8"
        # export PS1="\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "

        # [[ $PS1 && -f "$ENV_ROOT/share/bash-completion/bash_completion" ]] && \
        if [ -f "$ENV_ROOT/share/bash-completion/bash_completion" ]; then
            out_source bash_completion "$ENV_ROOT/share/bash-completion/bash_completion"
        fi
        out_alias ls 'ls --color' 
        # alias ls="ls --color"
        out_join ENVE_BASHOPTS ':'
        out_join ENVE_SHELLOPTS ':'
        out_list ENVE_BASHOPTS checkwinsize
        out_list ENVE_BASHOPTS autocd
    fi
    echo OUT prompt >&2
}

resolve_nix() {
    TABLE="$(cat "${configfile:--}")"
    echo IN nix >&2
    
    if [ "$(table_tail "enve\\.no_nix")" = "true" ]; then
        out_var SHELL "/usr/bin/bash"
        [ -n "$TABLE" ] && echo "$TABLE"
        echo OUT nix >&2
        return
    fi
    PRJ_NAME="$(table_tail "PRJ_NAME")"

    nix_channel_url="$(table_tail "nix\\.channel\\.url")"
    # nix_channel_sha256="$(table_tail nix.channel.sha256)"
    
    if [ -z "${nix_channel_url:-}" ]; then
        nix_channel_version="$(table_tail nix.channel.version)"
        if [ -n "$nix_channel_version" ]; then
            nix_channel_url="https://github.com/NixOS/nixpkgs/archive/$nix_channel_version.tar.gz"
        else
            # nix_channel_url="https://github.com/NixOS/nixpkgs/archive/17.09.tar.gz"
            nix_channel_url="https://github.com/NixOS/nixpkgs/archive/18.09.tar.gz"
        fi
        # nix_channel_sha256="405f1d6ba523630c83fbabef93f0da11ea388510a576adf2ded26a744fbf793e"
    fi


    pkgs="$(table_subset "nix\\.require" | as_concat ' ')"
    pkgs="$pkgs $(table_subset "nix\\.packages" | as_concat ' ')"

    echo "pkgs: $pkgs" >&2
    nix_root="$(resolve_path "$(table_tail "nix\\.root")")"
    nix_root=${nix_root:-/nix/var/nix/profiles/default}
    # if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
    #   . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
    # fi

    # echo "$(table_subset "nix\\.files")" >&2
    nix_extra=
    for file in $(table_subset "nix\\.files" | as_value); do
        absfile="$(resolve_path "$file")"
        nix_extra="${nix_extra}${newl}$(cat "$absfile")"
    done
    echo "==== NIX_EXTRA ====" >&2
    echo "$nix_extra"

    nix_config="$(
        { table_subset "nix.config\\..*"; } | as_postfix "nix.config\\." | \
        while read -r name value; do
            if [ -n "$name" ]; then
                echo "$name = $value;"
            fi
        done
    )"

    if env_root="$(
        NIX_REMOTE=daemon \
        NIX_SSL_CERT_FILE=/nix/var/nix/profiles/default/etc/ssl/certs/ca-bundle.crt \
        NIXPKGS_ALLOW_UNFREE=1 \
    "$nix_root"/bin/nix-build --no-out-link --show-trace - <<EOF
    let
      pkgs = import (builtins.fetchTarball {
        url = $nix_channel_url;
      }) { config = { $nix_config }; };
      $nix_extra
    in
      pkgs.buildEnv {
        name = "${PRJ_NAME:-}${PRJ_NAME:+-}env";
        paths = with pkgs; [
          coreutils diffutils findutils which file
          gnused gnugrep gawkInteractive gnutar gzip bzip2 less gettext
          git openssl_1_1_0 gnupatch
          xz unzip
          bashInteractive bashCompletion
          time rsync
          $pkgs
        ];
      }
    
EOF
    )"; then
        echo "env_root: $env_root" >&2
        out_var ENV_ROOT "$env_root"
        out_var SHELL "$env_root/bin/bash"
    fi


#     env_root="$(
#         NIX_REMOTE=daemon \
#         NIX_PATH=/nix/var/nix/profiles/per-user/root/channels \
#     $nix_root/bin/nix-build --no-out-link - <<EOF
#     with import <nixpkgs> { };
#     buildEnv {
#       name = "dummy";
#       paths = [
#         coreutils diffutils findutils which file
#         gnused gnugrep gawkInteractive gnutar gzip bzip2 less gettext
#         git-lfs git openssl_1_1_0
#         bashInteractive bashCompletion
#         $pkgs
#       ];
#     }
# EOF
#     )"

    [ -n "$TABLE" ] && echo "$TABLE"
    [ -n "${env_root:-}" ] && out_list PATH "$env_root/bin"
    echo OUT nix >&2
}

resolve_macos() {
    TABLE="$(cat "${configfile:--}")"
    echo IN resolve_macos >&2
    out_join PATH ':'
    [ -n "$TABLE" ] && echo "$TABLE"
    (
        # shellcheck disable=2123
        PATH=
        export PATH
        eval "$(/usr/libexec/path_helper -s)"
        IFS=':'
        for p in $PATH; do
            out_list PATH "$p"
        done
    )

    out_var SSH_AUTH_SOCK "$SSH_AUTH_SOCK"
    out_var enve.bound.ignore '**/.DS_Store'
    out_var enve.bound.ignore '**/.git/**'

    out_list BYPASS "TERMINFO"
    out_list BYPASS "KITTY_WINDOW_ID"
    out_list BYPASS "COLORTERM"

    # out_var LC_ALL "en_US.UTF-8"
    # out_var LC_CTYPE "en_US.UTF-8"
    # out_var LANG "en_US.UTF-8"
    # out_var PYTHONIOENCODING "utf-8:surrogateescape"

    echo OUT resolve_macos >&2
}

resolve_boundfiles() {
    # TODO: 與gitignore整合, 並且考慮enve.bound.ignore
    # 整個專案資料夾的所有檔案都理論上都是bound
    # 當bound沒有依賴專案資料夾以外的檔案, 而且所有的submodule也都是pure bound
    #   而且使用者沒有設定enve.bound.pure, 則此 enve.bound.pure=true
    # ignore順序
    # 1. +all
    # 2. include .gitignore
    # 3. +enve.bound
    # 4. include enve.bound.ignore
    TABLE="$(cat "${configfile:--}")"
    echo "IN resolve_boundfiles" >&2

    # TODO: PRJROOT must be abspath
    PRJROOT="$(resolve_path "$(table_tail "layout\\.root")")"

    bounds="$(cd "$PRJROOT"; find . ! -type d)"
    
    if [ -f "$PRJROOT/.gitignore" ]; then
        bounds="$(echo "$bounds" | gitignore_filter "$(cat "$PRJROOT/.gitignore")" )"
    fi
    if table_subset "enve\\.bound"; then
        bounds="$bounds${bounds:+$newl}$(table_subset "enve\\.bound" | as_concat "$newl" || true)"
    fi
    bounds="$(echo "$bounds" | gitignore_filter "$(table_subset "enve\\.bound\\.ignore" | as_concat "$newl" || true)" )"
    echo "== BOUND:" >&2
    echo "$bounds" >&2

    bounds_table="$(
        cd "$PRJROOT"
        while read -r path; do
            if [ -n "$path" ]; then
                out_var bound "$(resolve_symlinks "$path")"
            fi
        done <<EOF
$bounds
EOF
    )"

    echo "$TABLE"
    echo "$bounds_table"
}


filter_kv_in_table() {
    # echo "configfile: $(cat -)" >&2
    TABLE="$(cat "${configfile:--}")"
    echo IN filter_kv_in_table >&2
    echo "$TABLE" >&2
    echo "$TABLE" | { grep "^.*${tab}[^.]*${tab}" || true; }
    echo OUT filter_kv_in_table >&2
}



# if [ "${2:-}" = "test" ]; then
#     return 0
# fi

if [ "${TEST:-}" = "test" ]; then
    return 0
fi


echo "IN $0" >&2
resolve_first | resolve_basic | resolve_command | resolve_nix | resolve_terminal | resolve_prompt | {
    resolve_macos
} | resolve_boundfiles #| filter_kv_in_table

# resolve_first | resolve_basic | resolve_command | resolve_nix | resolve_terminal | resolve_prompt | {
#     resolve_macos
# } | filter_kv_in_table

echo "OUT $0" >&2




# resolve() {
# resolve_basic | resolve_nix | resolve_macos
# }

