#!/usr/bin/env bash

# shellcheck disable=2016
true

if [ -n "${HAVE_ENVE_ENVELIB:-}" ]; then
    return 0
fi
HAVE_ENVE_ENVELIB=1

# shellcheck source=libexec/enve/base
. "$ENVE_HOME/enve/base"
# shellcheck source=libexec/enve/findutils
. "$ENVE_HOME/enve/findutils"
# shellcheck source=libexec/enve/pathutils
. "$ENVE_HOME/enve/pathutils"
# shellcheck source=libexec/enve/cachelib
. "$ENVE_HOME/enve/cachelib"
# shellcheck source=libexec/enve/urlutils
. "$ENVE_HOME/enve/urlutils"

tab="$(printf '\tx')"
tab="${tab%x}"
feed="$(printf '\fx')"
feed="${feed%x}"
vtab="$(printf '\vx')"
vtab="${vtab%x}"
newl="$(printf '\nx')"
newl="${newl%x}"


# All function in this definition are design to compatible with posix shell.
# External Dependencies are awk(1), tr(1), pwd(1), ls(1), basename(1), dirname(1).
#
# The newline character in VALUE will be replaced to '\f' before store in table.
# Therefore VALUE can store any ascii character except '\f'
#
# table syntax:
#   TABLE   = (ENTRY '\n')*
#   ENTRY   = VTYPE '\t' KEY '\t' VALUE
#   KEY     = KEYCOMP ('.' KEYCOMP)*
#   VTYPE   = 'VAR' | 'RVAR' | 'FUNC' | 'ALIAS' | 'LIST' | 'JOIN' | 'SRC'
#   KEYCOMP = [^\n.]+
#   VALUE   = [^\n]*



# table_tail() {
#     vtype="${2:-VAR}"
#     echo "$TABLE" | grep -E "^${vtype}${tab}${1}${tab}" | tail -n 1 | cut -d"${tab}" -f3-
# }



_fast_table_match() {
    _key_cond=$1
    _inverse=${inverse:-}

    _sh_regex=
    _grep_regex=

    s=${_key_cond}
    replace '\.' 'z'
    _search_regex_symbol=$s
    _search_regex_symbol=${_search_regex_symbol%".*"}
    if      [ "${_search_regex_symbol#*[\*\.\+\?\[\]\(\)\{\}\^\$\|]}" = "${_search_regex_symbol}" ]; then
        s=${_key_cond}
        replace '.*' '*'
        _sh_regex=${s}
    else
        _grep_regex=${_key_cond}
    fi

    matchlines=
    if [ -n "${_sh_regex}" ]; then
        # fast prefix match
        while IFS="" read -r line; do
            if [ -z "$line" ]; then continue; fi
            mline=${line%${tab}*}
            if [ -z "${mline%$vtype$tab${_sh_regex}}" ]; then
                match=1
            else
                match=
            fi
            # echo "${_inverse} + ${match}: $_sh_regex : $mline : ${mline#$vtype$tab${_sh_regex}}" >&2
            if      { [ -n "${_inverse}" ] && [ -z "${match}" ]; } || \
                    { [ -z "${_inverse}" ] && [ -n "${match}" ]; }; then
                matchlines="${matchlines}$line$newl"
            fi
        done <<EOF
$TABLE
EOF
    else
        # regex match
        matchlines=$(printf %s\\n "$TABLE" | grep -E ${_inverse:+-v} \
                     "^${vtype}${tab}${_grep_regex}${tab}" || true)
    fi
    unset _key_cond _sh_regex _grep_regex _inverse _search_regex_symbol s line mline
}


fast_table_tail() {
    vtype="${2:-VAR}"
    _fast_table_match "$1"
    # echo "matchtable:" >&2
    # logtable "$TABLE"
    # echo "matchlines: $matchlines" >&2
    v=${matchlines%%$newl}
    v=${v##*$newl}
    v=${v#$vtype$tab*$tab}
    if [ -z "$v" ]; then
        v=${TABLE_DEFAULT:-}
    fi
    TABLE_TAIL=$v
    unset matchlines v
}


fast_table_subset() {
    vtype="${2:-VAR}"
    _fast_table_match "$1"
    kv=
    while read -r line; do
        if [ -n "$line" ]; then
            kv="${kv}${line#$vtype$tab}$newl"
        fi
    done <<EOF
$matchlines
EOF
    # TABLE_SUBSET=${kv%%$newl}
    TABLE_SUBSET=$kv
    unset matchlines line
}

fast_table_exclude() {
    vtype="${2:-VAR}"
    inverse=1 _fast_table_match "$1"
    kv=
    while read -r line; do
        if [ -n "$line" ]; then
            kv="${kv}${line#$vtype$tab}$newl"
        fi
    done <<EOF
$matchlines
EOF
    # TABLE_SUBSET=${kv%%$newl}
    TABLE_SUBSET=$kv
    unset matchlines line
}

table_tail() {
    vtype="${2:-VAR}"
    fast_table_tail "$@"
    printf %s\\n "$TABLE_TAIL"
    unset vtype
}

table_subset() {
    vtype="${2:-VAR}"
    fast_table_subset "$@"
    printf %s "$TABLE_SUBSET"
    unset vtype
}

table_exclude() {
    vtype="${2:-VAR}"
    fast_table_exclude "$@"
    printf %s "$TABLE_SUBSET"
    unset vtype
}







# _table_match() {
#     if [ "${1#*\*}" = "$1" ] && [ "${1#*\.}" = "$1" ]; then
#         # fast prefix match
#         while IFS="" read -r line; do
#             # echo "L: x_${line}_x" >&2
#             if [ "${line#$vtype$tab$1$tab}" != "$line" ]; then
#                 printf %s\\n "$line"
#             fi
#         done <<EOF
# $TABLE
# EOF
#     else
#         # regex match
#         printf %s\\n "$TABLE" | grep -E "^${vtype}${tab}${1}${tab}" || true
#     fi
# }

# table_tail() {
#     vtype="${2:-VAR}"
#     _val=
#     while IFS="" read -r line; do
#         if [ -n "$line" ]; then
#             _val=${line#$vtype$tab*$tab}
#         fi
#     done <<EOF
# $(_table_match "$1")
# EOF

#     if [ -n "${_val}" ]; then
#         printf %s\\n "${_val}"
#     elif [ -n "${TABLE_DEFAULT:-}" ]; then
#         printf %s\\n "${TABLE_DEFAULT}"
#     fi
#     unset vtype line _val
# }

# # table_subset() {
# #     vtype="${2:-VAR}"
# #     echo "$TABLE" | grep -E "^${vtype}${tab}${1}${tab}" | cut -d"${tab}" -f2-
# # }

# table_subset() {
#     vtype="${2:-VAR}"
#     while IFS="" read -r line; do
#         if [ -n "$line" ]; then
#             printf %s\\n "${line#$vtype$tab}"
#         fi
#     done <<EOF
# $(_table_match "$1")
# EOF
#     unset vtype line
# }

# table_exclude() {
#     vtype="${2:-VAR}"
#     echo "$TABLE" | grep -E -v "^${vtype}${tab}${1}${tab}" | cut -d"${tab}" -f2-
# }

# shellcheck disable=2120,2031
value_substi() {
    _cur="${_value}"
    # echo "value_substi ${_cur}" >&2
    _PASSVARS="$newl${PASSVARS:-}$newl"
    _newvalue=
    while [ "${_cur%\$\{*\}*}" != "${_cur}" ]; do

        # in case of '123${variable}456'
        #   _left   = '123'
        #   _center = 'variable'
        #   _right  = '456'
        _left=${_cur%%\$\{*\}*}
        _right=${_cur#*\$\{*\}}
        _center=${_cur%\}"${_right}"}
        _center=${_center#"$_left"\$\{}
        # echo "${_left}--${_center}--${_right}" >&2
        if [ "${_left#${_left%?}}" = "\\" ]; then
            _newvalue="${_newvalue}${_left%?}\${${_center}}"
            _cur=${_right}
            continue
        fi
        if [ "${_center%${_center#?}}" = "_" ]; then
            _newvalue="${_newvalue}${_left}\${${_center}}"
            _cur=${_right}
            continue
        fi
        if [ "${_center#*:[-+=]}" != "${_center}" ]; then
            _namepart=${_center%%:[-+=]*}
            _recpart=${_center#*:[-+=]}
        elif [ "${_center#*[-+=]}" != "${_center}" ]; then
            _namepart=${_center%%[-+=]*}
            _recpart=${_center#*[-+=]}
        else
            _namepart=${_center}
            _recpart=
        fi

        # echo "R:${_recpart:-}" >&2
        # echo "N:${_namepart}" >&2
        # echo "C:${_center}" >&2
        if [ -n "${_namepart}" ] && [ "${_namepart#*\$}" = "${_namepart}" ] && \
                                    [ "${_recpart#*\$\(}" = "${_recpart}" ]; then
            if [ "${_PASSVARS#*$newl$_namepart$newl}" = "${_PASSVARS}" ]; then
                eval _center=\$\{"${_center}"\}
            else
                # output the "'" escape form
                _center="'\"\${${_center}}\"'"
            fi
        else
            error "unsafe variable subsitution"
            return 1
        fi

        _newvalue="${_newvalue}${_left}${_center}"
        _cur=${_right}
    done
    _newvalue="${_newvalue}${_cur}"
    if [ "${1:-}" != nonfast ]; then
        _subsited_value=${_newvalue}
        # _value=${_newvalue}
    else
        # echo "${_newvalue}" >&2
        printf %s\\n "${_newvalue}"
    fi
}


table_substi() {
    # table values substitution
    (
        _table=$1
        vtypes=",${2:-VAR,LIST},"
        # use "$1" as variable table to make context
        while IFS="${tab}" read -r _vt _vk _value; do
            if [ "${_vt}" = "VAR" ] && [ "${_vk%\.*}" = "${_vk}" ]; then
                value_substi
                eval "${_vk}=\"\${_subsited_value}\""
            fi
        done <<EOF
$_table
EOF

        while IFS="${tab}" read -r _vt _vk _value; do
            if [ "${vtypes%,${_vt},*}" != "${vtypes}" ]; then
                value_substi
                _value=${_subsited_value}
            fi
            printf %s\\n "${_vt}${tab}${_vk}${tab}${_value}"
        done <<EOF
$TABLE
EOF
    )
}


fast_as_postfix() {
    _postfix=$1
    TABLE_AS=
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ]; then
            TABLE_AS="${TABLE_AS}${name#${_postfix}}${tab}${value}$newl"
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    unset _postfix name value
}

fast_as_rootkey() {
    TABLE_AS=
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ]; then
            TABLE_AS="${TABLE_AS}${name%.*}${tab}${value}$newl"
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    unset _postfix name value
}

fast_as_value() {
    TABLE_AS=
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ]; then
            if [ -n "$value" ]; then
                TABLE_AS="${TABLE_AS}$value$newl"
            else
                TABLE_AS=
            fi
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    unset name value
}


fast_as_tail() {
    fast_as_value
    TABLE_AS=${TABLE_AS%%$newl*}
    if [ -z "$TABLE_AS" ]; then
        TABLE_AS=${TABLE_DEFAULT:-}
    fi
}

fast_as_uniquekey() {
    TABLE_AS="$newl"
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ] && [ "${TABLE_AS%$newl$name$newl*}" = "${TABLE_AS}" ]; then
            TABLE_AS="${TABLE_AS}${name}${newl}"
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    TABLE_AS="${TABLE_AS#$newl}"
    # TABLE_AS="${TABLE_AS%$newl}"
    unset name value
}

fast_as_concat() {
    concat_by="${1:-}"
    fast_as_value
    if [ "$concat_by" != "$newl" ]; then
        s=$TABLE_AS
        replace "$newl" "$concat_by"
        TABLE_AS=$s
    fi
    TABLE_AS=${TABLE_AS%$concat_by}
    unset concat_by s
}

as_postfix() {
    TABLE_SUBSET=$(cat -) fast_as_postfix "$1"
    printf %s "$TABLE_AS"
}
as_rootkey() {
    TABLE_SUBSET=$(cat -) fast_as_rootkey
    printf %s "$TABLE_AS"
}
as_value() {
    TABLE_SUBSET=$(cat -) fast_as_value
    printf %s "$TABLE_AS"
}
as_uniquekey() {
    TABLE_SUBSET=$(cat -) fast_as_uniquekey
    printf %s "$TABLE_AS"
}
as_concat() {
    TABLE_SUBSET=$(cat -) fast_as_concat "$1"
    printf %s "$TABLE_AS"
}






# as_postfix() {
#     while IFS="${tab}" read -r name value; do
#         echo "${name#$1}${tab}${value}"
#     done
# }

# as_rootkey() {
#     while IFS="${tab}" read -r name value; do
#         echo "${name%.*}${tab}${value}"
#     done
# }

# as_value() {
#     _list=
#     while IFS="${tab}" read -r name value; do
#         if [ -n "$value" ]; then
#             # echo "$value"
#             _list="${_list}${_list:+$newl}$value"
#         else
#             _list=
#         fi
#     done
#     if [ -n "${_list}" ]; then
#         printf %s\\n "${_list}"
#     fi
#     unset name value _list
# }

# as_uniquekey() {
#     keys="$newl"
#     while IFS="${tab}" read -r name value; do
#         # if [ -n "$name" ] && [ "${keys/$name$newl/}" = "${keys}" ]; then
#         if [ -n "$name" ] && [ "${keys%$newl$name$newl*}" = "${keys}" ]; then
#             keys="${keys}${name}${newl}"
#         fi
#     done
#     keys="${keys#$newl}"
#     echo "${keys%$newl}"
#     unset keys
# }

# as_concat() {
#     concat="${1:-}"
#     # as_value | (c="$(cat)"; printf %s "${c%%$newl}") | {
#     s=$(as_value)
#     # s=${s%%$newl}
#     if [ "$concat" = "$newl" ]; then
#         printf %s\\n "$s"
#     elif [ -n "$concat" ]; then
#         # printf %s "${v%%$newl}" | tr "$newl" "$concat"
#         replace "$newl" "$concat"
#         printf %s\\n "$s"
#     else
#         # printf %s "${v%%$newl}" | tr -d "$newl"
#         replace "$newl" ""
#         printf %s\\n "$s"
#     fi
# }









fast_resolve_path() {
    if [ -z "$d" ]; then
        :
    elif [ "${d%"${d#?}"}" = '/' ]; then
        :
    elif [ -n "$PRJROOT" ]; then
        d="${PRJROOT%/}/$d"
    else
        fast_table_tail "layout\\.root"
        PRJROOT=${TABLE_TAIL:-$PWD}
        PRJROOT=${PRJROOT%/}
        d="${PRJROOT}/$d"
    fi
}

# resolve_path() {
#     # path in config file should relative to project root (layout.root)
#     if [ -z "$1" ]; then
#         return
#     fi
#     if [ "${1%"${1#?}"}" = '/' ]; then
#         echo "$1"
#         return
#     fi
#     if [ -z "${root:-}" ]; then
#         root=$(table_tail layout.root)
#     fi
#     if [ -z "${root:-}" ]; then
#         root="${PRJROOT:-}"
#     fi
#     if [ -z "$root" ]; then
#         root="${CONFIGROOT:-}"
#     fi
#     if [ -z "$root" ]; then
#         root="$(pwd)"
#     fi
#     echo "${root%/}/$1"
#     unset root
# }

out_var() {
    # echo "VAR${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
    echo "VAR${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_var_fast() {
    printf %s\\n "VAR${tab}$1${tab}$2"
}
out_var_just() {
    TABLE="${TABLE%%$newl}${TABLE:+$newl}${3:-VAR}${tab}$1${tab}$2"
}

out_raw_fast() {
    printf %s\\n "${3:-VAR}${tab}$1${tab}$2"
}

out_escape_fast() {
    s=$2
    replace "$newl" "$feed"
    printf %s\\n "${3:-VAR}${tab}$1${tab}$s"
    unset s
}

# out_module() {
#     printf %s\\t%s\\t%s\\n "$1" "$2" "$3"
# }
# out_rawvar() {
#     # echo "RVAR${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
#     echo "RVAR${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
# }

# out_func() {
#     # TODO: types $2
#     # funcbody="${2##*()}"
#     # echo "FUNC${tab}$1${tab}$(printf "%s" "$funcbody" | tr '\n' '\f')"
#     # unset funcbody
#     echo "FUNC${tab}$1${tab}$(s=${2##*()}; replace "$newl" "$feed"; printf "%s" "$s")"
# }

out_alias() {
    # echo "ALIAS${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
    echo "ALIAS${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_list() {
    # echo "LIST${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
    echo "LIST${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_join() {
    echo "JOIN${tab}$1${tab}$2"
}
out_source() {
    echo "SRC${tab}$1${tab}$2"
}
out_code() {
    echo "CODE${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
# out_secret() {
#     echo "SEC${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
# }


rcfile_parse_meta_table() {
    #
    # input
    #   $1 - rcfile path
    #
    # output
    #   META_TABLE

    META_TABLE=
    while read -r line; do
        case $line in
            \#"META: VAR$tab"*)
                    cuts=${line#\#"META: VAR$tab"}
                    key=${cuts%%$tab*}
                    s=${cuts#*$tab}
                    replace "${feed}" "${newl}"
                    value=$s
                    META_TABLE="${META_TABLE}$key$tab$value$newl"
                ;;
        esac
    done < "$1"
    unset line cuts key value s
}


fast_system_roles() {
    out=
    fast_get_system
    case "$ENVE_CACHED_OS" in
        FreeBSD) out="$out${out:+,}freebsd,bsd,unix,posix"; ;;
        Darwin) out="$out${out:+,}darwin,bsd,unix,posix"; ;;
        Linux) out="$out${out:+,}linux,unix,posix"; ;;
        MINGW32) out="$out${out:+,}nt,msystem,mingw,mingw32"; ;;
        MINGW64) out="$out${out:+,}nt,msystem,mingw,mingw64"; ;;
        MSYS*) out="$out${out:+,}nt,msystem,msys2"; ;;
        CYGWIN) out="$out${out:+,}nt,cygwin,posix"; ;;
    esac
    out_system_roles=$out
    unset out
}


_parse_keyvalue() {
    # params
    #   $1 - line
    # output
    #   key
    #   value

    line="$1"

    key=
    if [ "${line##*"\\="}" != "${line}" ]; then
        # value escape '\=' to '='
        s=$value
        replace "\\=" "="
        value=$s
        unset s
    else
        value="${line#*"="}"
        if [ "$value" != "$line" ]; then
            key="${line%%"="*}"
        fi
    fi

    if [ "${value#\\\[}" != "$value" ]; then
        # value escape starting '\[' to '['
        value=${value#\\}
    fi

    if [ -n "$key" ]; then
        junk=${key%%[![:space:]]*}
        key=${key#"$junk"}
        junk=${key##*[![:space:]]}
        key=${key%"$junk"}
    fi
    unset line
}


filter_roles() {
    # input
    #   roles
    # inout
    #   key

    s="$key${newl}"
    replace "," "@"
    # _roles=,$roles
    OLDIFS=$IFS; IFS=","
    for role in ${roles}; do
        replace "@$role@" "@"
        replace "@$role." "."
        replace "@$role$newl" "$newl"
    done
    IFS=$OLDIFS
    key=$s
    key="${key%$newl}"
    key="${key%\.}"
    unset OLDIFS role s
}


emit2() {
    # input
    #   roles
    #   key
    #   value

    key="$1"
    value="$2"
    filter_roles
    if [ "$key" = "${key%%@*}" ]; then
        if [ "$key" = "include" ] || [ "$key" = "inherit" ]; then
            s=$value
            replace "@" ","
            if [ "$s" != "${s#*,}" ]; then
                value_path=${s%%,*}
                value_roles=${s#*,}
            else
                value_path=$s
                value_roles=
            fi
            pass_roles=",${roles:+$roles,}"
            OLDIFS=$IFS; IFS=","
            for r in ${value_roles}; do
                if [ -n "$r" ] && [ "${pass_roles%,$r,*}" = "${pass_roles}" ]; then
                    pass_roles="$pass_roles$r,"
                fi
            done
            IFS=$OLDIFS
            pass_roles=${pass_roles%,}
            pass_roles=${pass_roles#,}
            # printf VAR\\t%s\\t%s\\n "__$key" "$value_path${pass_roles%,}"
            OUT_TABLE="${OUT_TABLE}VAR${tab}__$key${tab}$value_path${pass_roles:+,$pass_roles}${newl}"
            unset OLDIFS s r value_path value_roles pass_roles
        else
            # printf VAR\\t%s\\t%s\\n "$key" "$value"
            OUT_TABLE="${OUT_TABLE}VAR${tab}$key${tab}$value${newl}"
        fi
    fi
}



parse_config_non_recursive() {
    #
    # input
    #   $1 - path
    #   roles
    #   parse_inherit
    #   parse_profile_optional
    #
    # output
    #   OUT_TABLE
    #
    # inout
    #   loaded
    #
    OUT_TABLE=
    if ! config_path="$(canonicalize_symlinks "$1")"; then
        unset config_path
        if [ -z "${parse_profile_optional:-}" ]; then
            error "not a resolvable path '$1'"
            return 1
        else
            warning "WARNING: not a resolvable path '$1'"
            return
        fi
    fi

    if [ -z "${parse_profile_optional:-}" ] && [ ! -f "$config_path" ]; then
        error " no such config file $config_path"
        unset config_path
        return 1
    fi

    loaded=${loaded:-$newl}
    if [ "${loaded#$newl$config_path$newl}" != "$loaded" ]; then
        unset config_path
        return
    else
        loaded="$loaded$config_path$newl"
    fi

    d="$1"
    fast_dirname
    root_path=$(canonicalize_symlinks "$d")

    # trace "parsing [roles: ${roles}] ${config_path}"
    if [ -n "${parse_inherit:-}" ]; then
        # out_var_fast layout.root "$root_path"
        OUT_TABLE="${OUT_TABLE}VAR${tab}layout.root${tab}$root_path${newl}"
    fi
    unset d root_path

    fast_readtext "$config_path"
    parse_config_non_recursive_text "$text"

    OUT_TABLE="${OUT_TABLE}VAR${tab}bound${tab}$config_path${newl}"
    OUT_TABLE="${OUT_TABLE}VAR${tab}enve.configs${tab}$config_path${newl}"
    OUT_TABLE="${OUT_TABLE}VAR${tab}enve.roles${tab}$roles${newl}"

    unset text config_path
}


parse_config_non_recursive_text() {
    # input
    #   roles
    #   $1 - config_text
    # inout
    #   OUT_TABLE

    area=
    stab=
    stabkey=
    while read -r line; do
        junk=${line%%[![:space:]]*}
        line=${line#"$junk"}
        junk=${line##*[![:space:]]}
        line=${line%"$junk"}
        { [ -z "$line" ] ||
          [ "${line%"${line#?}"}" = ";" ] ||
          [ "${line%"${line#?}"}" = "#" ]; } && continue

        if [ -n "$stab$stabkey" ]; then
            if [ "${line#"${line%?}"}" = "\\" ] && [ "${line#"${line%??}"}" != "\\\\" ]; then
                stab="${stab}${line%?}"
            else
                [ "${line#"${line%??}"}" = "\\\\" ] && line="${line%\\}"
                stab="${stab}${line}"
                emit2 "$stabkey" "$stab"
                stabkey=
                stab=
            fi
        elif [ "${line%"${line#?}"}" = '[' ] && [ "${line#"${line%?}"}" = ']' ]; then
            new_area="${line#\[}"
            new_area="${new_area%\]}"

            # Note: original key should not contain character '@' or ',', otherwise role test failed
            junk=${new_area%%[![:space:]]*}
            new_area=${new_area#"$junk"}
            junk=${new_area##*[![:space:]]}
            new_area=${new_area%"$junk"}

            area="$new_area"
            unset new_area
        elif [ "${area}" = "comment" ]; then
            :;
        else
            _parse_keyvalue "$line"
            if [ -n "${area}${key:+.}${key}" ]; then
                if [ "${value#"${value%?}"}" = "\\" ] && [ "${value#"${value%??}"}" != "\\\\" ]; then
                    stabkey="${area}${area:+${key:+.}}${key}"
                    stab="${stab}${value%?}"
                else
                    [ "${value#"${value%??}"}" = "\\\\" ] && value="${value%\\}"
                    emit2 "${area}${area:+${key:+.}}${key}" "$value"
                fi
            else
                :
            fi
        fi
    done <<EOF
$1
EOF
    unset junk line area stab stabkey key value
}



enve_parse_config() {
    #
    # input
    #   [parse_inherit]
    #   [parse_profile_optional]
    #   [roles]
    #   [loaded]
    #   [stage1_is_text]
    #   $1 - STAGE1_FILE or STAGE1_TEXT
    #
    # inout
    #   TABLE
    #

    if [ -n "${stage1_is_text:-}" ]; then
        OUT_TABLE=
        roles=$roles parse_config_non_recursive_text "$1"
        STAGE1_TABLE=$OUT_TABLE
        unset stage1_is_text
    else
        # echo "parse_inherit:$parse_inherit" >&2
        roles="$roles" \
        parse_inherit="${parse_inherit:-}" \
        parse_profile_optional="${parse_profile_optional:-}" \
        parse_config_non_recursive "$1"
        # LOGLEVEL=DEBUG log "=== parse ???-$1 ==="
        # LOGLEVEL=DEBUG logtable "$OUT_TABLE"
        STAGE1_TABLE=$OUT_TABLE
    fi
    unset OUT_TABLE


    _ACC_TABLE=$TABLE

    TABLE=$STAGE1_TABLE
    fast_table_subset "__include"
    fast_as_value
    paths=$TABLE_AS
    fast_table_subset "__inherit"
    fast_as_value
    paths="$paths$newl$TABLE_AS"

    TABLE=${_ACC_TABLE}
    unset _ACC_TABLE TABLE_AS TABLE_SUBSET

    _need_stage2=
    _need_parserenv=
    while read -r path; do
        if [ -n "$path" ]; then
            _need_stage2=1
            if [ "${path%://*}" != "$path" ]; then
                _need_parserenv=1
            fi
        fi
    done <<EOF
$paths
EOF
    unset paths path

    if [ -z "$_need_stage2" ]; then
        TABLE="$TABLE${TABLE:+$newl}$STAGE1_TABLE"
        unset _need_stage2 _need_parserenv
        return
    elif [ -z "$_need_parserenv" ]; then
        unset _need_stage2 _need_parserenv
    else
        unset _need_stage2 _need_parserenv
        # TODO:
        # origin_ENVE_PROFILE=$ENVE_PROFILE
        # wait_ENVE_PROFILE=$ENVE_PROFILE
        # ENVE_PROFILE=
        # OLDIFS=$IFS; IFS=,
        # for cfile in $wait_ENVE_PROFILE; do
        #     IFS=$OLDIFS
        #     parse_unified_download "$cfile" "%cache" "auto" "noerror" || true
        #     if [ "${dl#cp}" != "$dl" ] || [ "$dl" = "relative" ]; then
        #         # cfile is a local path
        #         if [ -d "$cfile" ]; then
        #             ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$cfile/enve.ini"
        #         else
        #             ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$cfile"
        #         fi
        #     else
        #         # cfile is a remote url
        #         cfile="$(settrace; fetch "$cfile" "%cache" "auto")/enve.ini"
        #         ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$cfile"
        #     fi
        # done
    fi

    parse_inherit=
    while IFS="$tab" read -r vtype key value; do
        unset STAGE1_TABLE
        if [ "$key" = "__include" ] || [ "$key" = "__inherit" ]; then
            if [ "$key" = "__inherit" ]; then
                if [ -z "$parse_inherit" ]; then
                    parse_inherit=1
                else
                    error "cannot inherit multiple enve profile"
                    return 1
                fi
            fi
            path=${value%%,*}
            if [ "${path%${path#?}}" = "+" ]; then
                path=${path#?}
                parse_profile_optional=1
            else
                parse_profile_optional=
            fi
            if ! parse_inherit=$parse_inherit \
                 parse_profile_optional=$parse_profile_optional \
                 roles=${value#*,} enve_parse_config "$path"; then
                return 1
            fi
        elif [ -n "$key" ]; then
            TABLE="${TABLE}$vtype${tab}$key${tab}$value${newl}"
        fi
    done <<EOF
$STAGE1_TABLE
EOF
    unset parse_inherit parse_profile_optional
}




# variable_action() {
#     case $name in
#         TERMSIZE)
#                 if [ -n "$r_value" ] && [ "$target" = "shell" ] && [ -x "/usr/bin/tput" ]; then
#                     # echo -e -n "\033[8;10;140t"
#                     width="${r_value%%x*}"
#                     height="${r_value##*x}"
#                     eval_line "OLD_COLUMNS=\$(/usr/bin/tput cols)"
#                     eval_line "OLD_LINES=\$(/usr/bin/tput lines)"
#                     # eval_line "echo -e -n \"\\033[8;${height};${width}t\""
#                     # exithook="${exithook}${exithook:+$newl}  echo -e -n \"\\033[8;\${OLD_LINES};\${OLD_COLUMNS}t\""
#                     eval_line "printf '\\033[8;%s;%st' \"${height}\" \"${width}\""
#                     exithook="${exithook}${exithook:+$newl}  printf '\\033[8;%s;%st' \"\${OLD_LINES}\" \"\${OLD_COLUMNS}\""
#                 fi
#             ;;
#         TERMTHEME)
#                 fast_get_system
#                 if [ -n "$r_value" ] && [ "$target" = "shell" ] && \
#                    [ "$ENVE_CACHED_OS" = "Darwin" ]; then
#                     eval_line 'OLD_TERMTHEME="$TERMTHEME"'
#                     eval_line "$ENVE_HOME/enve/core/macos/term_theme.applescript '$r_value'"
#                     exithook="${exithook}${exithook:+$newl}  $ENVE_HOME/enve/core/macos/term_theme.applescript \"\$OLD_TERMTHEME\""
#                 fi
#             ;;
#     esac
#     # eval_line "$name='$(eval echo "$r_value")'; export $name"
#     eval_line "$name='$r_value'; export $name"
# }


eval_line() {
    LOGLEVEL=DEBUG log "EVAL: $1"
    echo "$1"
}

execute_envdef() {
    TABLE="$1"
    target=$2
    shift 2

    if ! TABLE=$(settrace
                 table_substi "$TABLE"); then
        return 1
    fi

    _lists=
    exithook=
    while IFS="$tab" read -r vtype name value; do
        if [ "$vtype" = "VAR" ] && [ "${name#*.}" != "$name" ]; then
            continue
        elif [ "${vtype} ${name}" = "VAR bound" ]; then
            continue
        fi

        # cwd=$(TABLE=$PAST_TABLE table_tail exec.cwd)
        # cwd=${cwd:-%cwd}
        # if [ "$cwd" = "%cwd" ]; then
        #     :
        # elif [ "${cwd%"${cwd#?????}"}" = "%root" ]; then
        #     # echo "%root" >&2
        #     # TABLE=$PAST_TABLE table_tail layout.root >&2
        #     eval_line 'cd "'"$(TABLE=$PAST_TABLE table_tail layout.root)${cwd#\%root}"'"'
        # else
        #     eval_line 'cd "'"$cwd"'"'
        # fi

        s=$value
        replace "$feed" "$newl"
        replace "'" "'\\''"
        r_value=$s
        case $vtype in
            VAR)
                    eval_line "$name='$r_value'; export $name"
                ;;
            LIST)
                    # eval "_LIST_$name='$(eval echo \$_LIST_$name)$(eval echo \$\{_LIST_$name:+\$_JOIN_$name\})$value'"
                    # eval_line "eval $name='$(eval echo "\$_LIST_$name")'; export $name"
                    if eval [ -z \""\$_JOIN_$name"\" ]; then
                        continue
                    fi
                    if [ -n "$r_value" ]; then
                        # eval eval echo "_LIST_$name='\${_LIST_$name}\${_LIST_$name:+\$_JOIN_$name}\$r_value'" >&2
                        eval eval "_LIST_$name='\${_LIST_$name}\${_LIST_$name:+\$_JOIN_$name}\$r_value'"
                    else
                        eval "_LIST_$name="
                    fi
                    # eval_line "$name='$(eval echo "\$_LIST_$name")'; export $name"
                ;;
            JOIN)
                    eval "_JOIN_$name='$value'; _LIST_$name=\"\${_LIST_$name:-}\""
                    _lists="${_lists}${_lists:+ }$name"
                    # eval_line "export $name=''"
                    # eval_line "export $name"
                ;;
            ALIAS)
                    eval_line "alias $name='$r_value'"
                ;;
            SRC)
                    eval_line ". '$r_value'"
                ;;
            CODE)
                    eval_line "$value"
                ;;
            SEC)
                    eval_line "$name=\$($r_value); export $name"
                ;;
            EXEC)
                    set -- "$@" "$r_value"
                ;;
            META)
                    eval_line "#META: VAR${tab}$name${tab}$r_value"
                ;;
            HOOK)
                    eval ${name}hook=\"\${${name}hook}\$value\$newl\"
                ;;
        esac
    done <<EOF
$TABLE
EOF

    for name in ${_lists}; do
        # TODO: need test with variable subsitution
        if eval [ -n "\$_LIST_$name" ]; then
            eval_line "$name='$(eval printf %s\\\\n \""\$_LIST_$name"\")'; export $name"
        fi
    done


    eval_line 'unset ENV'
    if [ "$target" = "shell" ]; then
        eval_line 'onexit() { '
        eval_line '  '"${exithook:-true}"
        eval_line '}'
        eval_line 'trap onexit INT TERM EXIT'
#     elif [ "$target" = "test" ]; then
#         eval_line '. $ENVE_HOME/enve/testlib'
#         eval_line 'ENVE_TEST_OUTPUT=${ENVE_TEST_OUTPUT:-$(mkdtemp "$(get_tempdir)"/enve-test.XXXXXX)}; export ENVE_TEST_OUTPUT'
#         eval_line 'TEST_OUTPUT=$ENVE_TEST_OUTPUT; export TEST_OUTPUT'
#         eval_line 'CACHED=$TEST_OUTPUT harness '\\
#         while IFS="$tab" read -r casename cmd; do
#             if [ -n "$casename" ]; then
#                 eval_line '  "'"$casename"'" "'"$cmd"'" '\\
#             fi
#         done <<EOF
# $(TABLE=$PAST_TABLE table_subset "test\\.jobs\\..*" | as_postfix "test\\.jobs\\.")
# EOF
#         eval_line '  ;'
    else
        # TODO: test this
        eval_line 'case ${ENVE_CHAINEXEC_STAGE:-1} in '
        stage=1
        if [ $# -gt 0 ]; then
            for execstmt in "$@"; do
                if [ "$stage" -eq $# ]; then
                    if [ "${execstmt%${execstmt#?}}" = ':' ]; then
                        eval_line "  $stage) ${execstmt%:} \"\$@\";;"
                    else
                        eval_line "  $stage) exec ${execstmt} \"\$@\";;"
                    fi
                else
                    eval_line "  $stage) ENVE_CHAINEXEC_STAGE=$((stage + 1)) exec ${execstmt%__chain__*} sh \$0 \"\$@\" ${execstmt#*__chain__} ;;"
                fi
                stage=$((stage + 1))
            done
        else
            eval_line "  $stage) exec \"\$@\";;"
        fi
        eval_line 'esac'
        # elif [ "$target" = "module" ] || [ "$target" = "loader" ]; then
        #     eval_line 'if [ -z "${sh_module:-}" ]; then'
        #     eval_line '  exec "$@"'
        #     eval_line 'fi'
        # else
        #     eval_line 'exec "$@"'
        # fi
    fi
    # eval_line
    # case ${ENVE_CHAINEXEC_STAGE:-1} in
    #     1) ENVE_CHAINEXEC_STAGE=2 exec aaa $0 ;;
    #     2) ENVE_CHAINEXEC_STAGE=3 exec bbb $0 ;;
    #     3) exec ccc ;;
    # esac
}




true '
    fire_chain 改用 eval 機制
    eval.value
    eval.table
    eval.bound
    可以fire一個env行程來取得stdout的內容
    這中間可以通過注入的方法來更動內層次的設定依賴
    eval.value.$variable_name.fire = */enve.ini@target@role
    eval.value.$variable_name.config.$key = $value

    這個方法類似import機制
'


# get_module_info() {
#     : '
#     define.module                           模組定義
#     define.module.$i.$p.name     default is "$dirname"/*.enve.ini
#     define.module.$i.$p.procedure  must set
#     define.module.$i.$p.native_exec
#             default is false, no create enve
#     define.module.$i.$p.source_exec
#             default is false, not use fork, use "." instand
#     define.module.$i.$p.exec     default is %root/$procedure.enve.module
#     (X)define.module.$i.$p.order    must set
#     define.module.$i.$p.after    this may help ordering modules
#     define.module.$i.$p.before
#     '

#     : '

#     pasre `enve.ini` in module base folder to get module information.

#     @param module_root: base path of module
#     @print: [name,procedure,after,before,exec,options,enve path, ...]
#     '

#     module_root=$1
#     module_names=" "
#     TABLE=$(roles="module-info" parse_config_recursive "$module_root/enve.ini")
#     if [ -z "$TABLE" ]; then
#         return 1
#     fi
#     module_table=$(table_subset "define\\.module\\..*")
#     if [ -n "$module_table" ]; then
#         while IFS="$tab" read -r key value; do
#             # shellcheck disable=2034
#             IFS="." read -r __define __module name proce attrib <<EOF
# $key
# EOF
#             s=$name
#             replace "-" "_"
#             vname=$s
#             if [ "$attrib" = "after" ] || [ "$attrib" = "before" ]; then
#                 s=$value
#                 replace "," ":"
#                 s=${s##:}
#                 s=${s%%:}
#                 eval "MODULE_${vname}_${proce}_${attrib}=\"\${MODULE_${vname}_${proce}_${attrib}:-}\${s}:\""
#             else
#                 eval "MODULE_${vname}_${proce}_${attrib}=\$value"
#             fi
#             if [ -n "${module_names#*" $name/$proce "*}" ]; then
#                 module_names="$module_names$name/$proce "
#             fi
#         done <<EOF
# $module_table
# EOF
#     fi


#     for name_proce in $module_names; do
#         IFS='/' read -r name proce <<EOF
# $name_proce
# EOF
#         # name=${name_proce%%/*}
#         # proce=${name_proce##*/}
#         procedure=$proce

#         s=$name
#         replace "-" "_"
#         vname=$s

#         eval native_exec="\${MODULE_${vname}_${proce}_native_exec:-false}"
#         eval source_exec="\${MODULE_${vname}_${proce}_source_exec:-false}"
#         eval exec="\${MODULE_${vname}_${proce}_exec:-\$module_root/\$procedure.enve.module}"
#         eval enve="\${MODULE_${vname}_${proce}_enve:-./enve.ini}"
#         eval after="\":\${MODULE_${vname}_${proce}_after:-}\""
#         eval before="\":\${MODULE_${vname}_${proce}_before:-}\""

#         options=
#         if [ "$native_exec" = "true" ]; then
#             options="${options}native_exec=1;"
#         fi
#         if [ "$source_exec" = "true" ]; then
#             options="${options}source_exec=1;"
#         fi
#         exec=$(cd "$module_root"; canonicalize_symlinks "$exec")
#         enve=$(cd "$module_root"; canonicalize_symlinks "$enve")
#         # path=$(cd "$module_root"; canonicalize_symlinks "$module_root")
#         path=$(table_tail layout.root)
#         printf '%s,%s,%s,%s,%s,%s,%s,%s\n' \
#             "$name" "$procedure" "$after" "$before" "$exec" "$options" "$enve" "$path"
#     done
# }

_clock() {
    echo "[$(($(/nix/store/l687wir6a2iy3928hbv2n5y2nx1afkr8-boot-env/bin/date +%s%N) / 1000000))] $1" >&2
}

get_module_info() {
    : '
    define.module                           模組定義
    define.module.$i.$p.name     default is "$dirname"/*.enve.ini
    define.module.$i.$p.procedure  must set
    define.module.$i.$p.native_exec default is false, no create enve
    define.module.$i.$p.source_exec default is false, not use fork, use "." instand
    define.module.$i.$p.exec     default is %root/$procedure.enve.module
    (X)define.module.$i.$p.order    must set
    define.module.$i.$p.after    this may help ordering modules
    define.module.$i.$p.before
    '

    : '

    pasre `enve.ini` in module base folder to get module information.

    @param module_root: base path of module
    @print: [name,procedure,after,before,exec,options,enve,path, ...]
    '

    module_root=$1
    module_names=" "
    # TABLE=$(roles="module-info" parse_config_recursive "$module_root/enve.ini")
    # if [ -z "$TABLE" ]; then
    #     return 1
    # fi
    TABLE=
    if ! parse_inherit=1 \
         parse_profile_optional="" \
         roles="module-info" loaded="" enve_parse_config "$module_root/enve.ini"; then
        return 1
    fi

    fast_table_tail "layout\\.root"
    path=$TABLE_TAIL
    # echo "LAYOUTROOT: $path" >&2

    fast_table_subset "define\\.module\\..*"
    while IFS="$tab" read -r key value; do
        if [ -z "$key" ]; then
            continue
        fi
        name=${key#*.*.}
        name=${name%.*.*}
        proce=${key#*.*.*.}
        proce=${proce%.*}
        attrib=${key#*.*.*.*.}

        s=$name
        replace "-" "_"
        vname=$s
        if [ "$attrib" = "after" ] || [ "$attrib" = "before" ]; then
            s=$value
            replace "," ":"
            s=${s##:}
            s=${s%%:}
            eval "MODULE_${vname}_${proce}_${attrib}=\"\${MODULE_${vname}_${proce}_${attrib}:-}\${value}:\""
        else
            eval "MODULE_${vname}_${proce}_${attrib}=\$value"
        fi
        # eval "MODULE_${vname}_${proce}_${attrib}=\$value"
        if [ -n "${module_names#*" $name/$proce "*}" ]; then
            module_names="$module_names$name/$proce "
        fi
    done <<EOF
$TABLE_SUBSET
EOF

    for name_proce in $module_names; do
        name=${name_proce%%/*}
        proce=${name_proce##*/}
        procedure=$proce

        s=$name
        replace "-" "_"
        vname=$s

        m_dict="MODULE_${vname}_${proce}"
        eval native_exec="\${${m_dict}_native_exec:-false}"
        eval source_exec="\${${m_dict}_source_exec:-false}"
        eval exec="\${${m_dict}_exec:-\$module_root/\$procedure.enve.module}"
        eval enve="\${${m_dict}_enve:-./enve.ini}"
        eval after="\":\${${m_dict}_after:-}\""
        eval before="\":\${${m_dict}_before:-}\""

        eval [ \"\${${m_dict}_native_exec+x}\" = x ] && unset ${m_dict}_native_exec
        eval [ \"\${${m_dict}_source_exec+x}\" = x ] && unset ${m_dict}_source_exec
        eval [ \"\${${m_dict}_exec+x}\" = x ] && unset ${m_dict}_exec
        eval [ \"\${${m_dict}_enve+x}\" = x ] && unset ${m_dict}_enve
        eval [ \"\${${m_dict}_after+x}\" = x ] && unset ${m_dict}_after
        eval [ \"\${${m_dict}_before+x}\" = x ] && unset ${m_dict}_before

        options=
        if [ "$native_exec" = "true" ]; then
            options="${options}native_exec=1;"
        fi
        if [ "$source_exec" = "true" ]; then
            options="${options}source_exec=1;"
        fi
        # exec=$(cd "$module_root"; canonicalize_symlinks "$exec")
        # enve=$(cd "$module_root"; canonicalize_symlinks "$enve")
        # fast_table_tail "layout\\.root"
        # path=$TABLE_TAIL
        # echo "LAYOUTROOT: $path" >&2

        exec="$path/${exec#./}"
        enve="$path/${enve#./}"
        # path=$(cd "$module_root"; canonicalize_symlinks "$module_root")
        # path=$(table_tail layout.root)
        # path=$module_root
        printf '%s,%s,%s,%s,%s,%s,%s,%s\n' \
            "$name" "$procedure" "$after" "$before" "$exec" "$options" "$enve" "$path"
    done
    unset m_native_exec m_source_exec m_exec m_enve m_after m_before
}


module_sort_after() {
    # arguments:
    #   modules
    #   name
    #   procefure
    #   afters
    #   befores
    # if [ -z "${name:-}" ]; then

    # shellcheck disable=2034
    IFS="," read -r name procedure afters befores remain<<EOF
$1
EOF
    # fi

    write_to=${2:-modules}
    # echo "MOD: $modules" >&2
    # echo "INST: $1" >&2
    min=
    max=
    e_index=0
    if [ -n "$modules" ]; then
        while IFS="," read -r e_name e_procedure e_afters e_befores e_remain; do
            if [ -z "${e_afters#*":$name:"*}" ] && [ "${max:-0}" -le "$e_index" ]; then
                max=$((e_index))
            fi
            if [ -z "${befores#*":$e_name:"*}" ] && [ "${max:-0}" -le "$e_index" ]; then
                max=$((e_index))
            fi
            if [ -z "${e_befores#*":$name:"*}" ] && [ "${min:-1000}" -ge "$e_index" ]; then
                min=$((e_index + 1))
            fi
            if [ -z "${afters#*":$e_name:"*}" ] && [ "${min:-1000}" -ge "$e_index" ]; then
                min=$((e_index + 1))
            fi
            e_index=$((e_index + 1))
        done <<EOF
$modules
EOF
    fi
    if [ -z "$min" ]; then
        min=0
    fi
    if [ -z "$max" ]; then
        max=$e_index
    fi
    if [ "$min" -gt "$max" ]; then
        _fatal "module ordering conflict, min: $min, max: $max"
        return 2
    else
        :
        # _debug "min: $min, max: $max | $name/$procedure($afters,$befores)"
    fi

    e_index=0
    head=
    tail=
    found_duplicated=
    found_last_bound=
    if [ -n "$modules" ]; then
        while IFS="," read -r e_name e_procedure e_afters e_befores e_remain; do
            if [ "$e_name" = "$name" ] && [ "$e_procedure" = "$procedure" ]; then
                found_duplicated=1
            fi
            if  [ -z "$found_last_bound" ] && [ $max -le $e_index ]; then
                found_last_bound=1
            fi
            if [ -z "$found_last_bound" ]; then
                head="${head:+$head$newl}$e_name,$e_procedure,$e_afters,$e_befores,$e_remain"
            else
                tail="${tail:+$tail$newl}$e_name,$e_procedure,$e_afters,$e_befores,$e_remain"
            fi
            e_index=$((e_index + 1))
        done <<EOF
$modules
EOF
    fi

    # echo "$min, $max" >&2
    # echo "head: $head" >&2
    # echo "tail: $tail" >&2
    if [ -n "$found_duplicated" ]; then
        eval "$write_to=\"\${head}\${tail:+\$newl\$tail}\""
    else
        eval "$write_to=\"\${head:+\$head\$newl}\$name,\$procedure,\$afters,\$befores,\$remain\${tail:+\$newl\$tail}\""
    fi
    if [ -n "${nonfast:-}" ]; then
        eval echo "\"\$$write_to\""
        # echo "$modules"
    fi
}



exec_loaders_with_info() {
    # -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
    # loader 將會試圖從設定檔中解出更多外部模組
    # 第一個執行的永遠是 $ENVE_HOME/evne/enve.loader
    # 被讀進來的模組如果含有enve.loader, 則會加入loader的行列

    # params:
    #   p_init_module_info
    #   p_fire
    #   TABLE
    # output:
    #   module_loaded
    #   isolation_modules

    get_next_loader() {
        loader_enve=
        loader_exec=
        loader_options=
        loader_path=
        while IFS="," read -r   e_name e_procedure e_afters e_befores \
                                e_exec e_options e_enve e_path; do
            if [ "$loader_execed" = "${loader_execed%,$e_name,}" ]; then
                loader_enve=$e_enve
                loader_exec=$e_exec
                loader_options=$e_options
                loader_path=$e_path
                loader_execed="${loader_execed}$e_name,"
                break
            fi
        done <<EOF
$loader_infos
EOF
    }

    p_fire=${p_fire:-fire}
    # loader_infos="init,loader,${init_module_path},,,"
    module_loaded=
    loader_infos=$p_init_module_info
    loader_execed=,

    get_next_loader
    while [ -n "$loader_exec" ]; do
        if [ -x "$loader_exec" ]; then
            if ! module_dirs="$(unset module_loaded loader_infos isolation_modules
                                echo "$TABLE" | ENVE_PROFILE="$loader_enve" \
                                                ZERO="$loader_path" \
                                                MODULE_OPTION="$loader_options" \
                                                $p_fire loader "$loader_exec")"; then
                _error "loader execute failed"
                return 1
            fi
            if [ -n "$module_dirs" ]; then
                while read -r moddir; do
                    if mod_infos=$(get_module_info "$moddir"); then
                        while read -r modinfo; do
                            e_procedure=${modinfo#*,}
                            e_procedure=${e_procedure%%,*}
                            # echo "ISO: $isolation_modules" >&2
                            # LOGTYPE='load' _info "$e_name/$e_procedure"
                            if [ "$e_procedure" = "loader" ]; then
                                modules=$loader_infos module_sort_after "$modinfo" loader_infos
                            elif [ "$e_procedure" = "module" ]; then
                                modules=$module_loaded module_sort_after "$modinfo" module_loaded
                            elif [ "$e_procedure" = "post" ]; then
                                :
                            elif [ "$e_procedure" = "isolation" ]; then
                                modules="${isolation_modules:-}" module_sort_after "$modinfo" isolation_modules

                            else
                                :
                            fi
                        done <<EOF
$mod_infos
EOF
                    else
                        _warning "get_module_info error on $moddir"
                    fi
                done <<EOF
$module_dirs
EOF
            fi
        fi
        get_next_loader
    done
    unset loader_infos
    # unset loader_execed next_loaders loader_path module
    # module_loaded=${module_loaded##"$newl"}
    # module_loaded=${module_loaded%%"$newl"}
}



resolve_with_info() {
    # input:
    #   p_module_loaded
    #   p_fire
    # global:
    #   TABLE

    p_fire=${p_fire:-fire}
    # _trace "module_paths $module_paths"
    # [ -n "$p_module_loaded" ] || {
    #     _fatal "assert \$p_module_loaded != ''"
    #     return 1
    # }
    while IFS="," read -r   e_name e_procedure e_afters e_befores \
                            e_exec e_options e_enve e_path; do
        if [ -z "$e_name" ]; then continue; fi

        LOGTYPE='module' _info "$e_name/$e_procedure: $e_exec"
        if [ -x "$e_exec" ]; then
            if ! TABLE="$(  unset p_module_loaded
                            echo "$TABLE" | ENVE_PROFILE="$e_enve" \
                                            p_fire="" \
                                            ZERO="$e_path" \
                                            MODULE_OPTION="$e_options" \
                                            MODULE_NAME="$e_name" \
                                            $p_fire module "$e_exec")"; then
                _error "module execute error at $e_name"
                return 1
            fi
            # TODO: move to every module code
            ls_prefix="${e_path}" fileonly=1 recursive=1 listdir "$e_path"
            while read -r modulebound; do
                if [ -n "$modulebound" ]; then
                    out_var_just enve.bound "$modulebound"
                fi
            done <<EOF
${_list}
EOF
        fi
        out_var_just module.loaded "$e_name"
    done <<EOF
$p_module_loaded
EOF
unset   e_name e_procedure e_afters e_befores \
        e_exec e_options e_enve e_path _list
}



get_rcfile_from_profiles_nocache() {
    # input:
    #   ENVE_PROFILE
    #   ENVE_ROLES
    #   ENVE_CONFIG
    #   RCFILE_PATH
    # output:
    #   boundfiles
    # sideeffect:
    #   write $RCFILE_PATH

    # proc            cond    hash                    vaild       make
    # --------------------------------------------------------------------
    # final-rc        -       url|profile             rc+marks    genrcfile
    #   checkout      url     url|profile             -           fetch
    #   paser&load    -       -
    #   settle        m       sub(s, pTABLE)          rootmark    settle
    #   install       m       sub(i, pTABLE)+artifact installmark unpack
    #     build       m       sub(b, pTABLE)+source   artifact    exec build
    #       build-rc  m       sub(b, pTABLE)          rc          genrcfile
    #   setup         m       sub(u, pTABLE)          setupmark   setup


    # if [ "$ENVE_PROFILE" = "$ENVE_HOME/enve/enve.ini" ]; then
    #     echo "!!!! $ENVE_HOME/enve/enve.ini" >&2
    #     TABLE=
    #     out_var_just core.target $target
    #     out_var_just sh_module 1
    # else

    # parse procedure
    TABLE=
    out_var_just core.target $target
    if !    stage1_is_text=1 \
            roles="" loaded="" \
            parse_inherit="" \
            parse_profile_optional="" \
            enve_parse_config "$ENVE_CONFIG_TEXT"; then
        _error "parse_config failed"
        return 1
    fi

    # _trace "=============$newl$TABLE"
    LOGLEVEL=DEBUG log "=== parse ???-$target ==="
    LOGLEVEL=DEBUG logtable "$TABLE"

    # TODO: decrepate nobound
    # if [ -z "$(table_subset "enve\\.configs")" ]; then
    #     out_var_just enve.nobound true
    # fi

    # load procedure
    if !    TABLE="$TABLE" \
            p_init_module_info="base,loader,:,:,\
$ENVE_HOME/enve/core/base/enve.loader,\
source_exec=1;native_exec=1;,,\
$ENVE_HOME/enve/core/base" \
            exec_loaders_with_info; then
        _error "exec_loaders failed"
        return 1
    fi


    while IFS="," read -r e_name e_procedure e_remain; do
        if [ -n "$e_name" ]; then
            LOGTYPE='iso' _info "$e_name/$e_procedure"
            last_isolation_name=$e_name
        fi
    done <<EOF
$isolation_modules
EOF

    while IFS="," read -r   e_name e_procedure e_afters e_befores \
                            e_exec e_options e_enve e_path; do
        if [ "$e_name" = "${last_isolation_name:-__NOT_FOUND__}" ]; then
            out_var_just "isolation.exec" "$e_exec" META
            out_var_just "isolation.options" "$e_options" META
            out_var_just "isolation.enve" "$e_enve" META
        fi
    done <<EOF
$isolation_modules
EOF
    unset last_isolation_name \
          e_name e_procedure e_afters e_befores \
          e_exec e_options e_enve e_path


    # add extra enve bound files
    fileonly=1 recursive="" listdir "${ENVE_HOME}/enve"
    while read -r envebound; do
        if [ -n "$envebound" ]; then
            out_var_just enve.bound "$envebound"
        fi
    done <<EOF
${_list}
EOF
    unset _list

    # resolve procedure
    if ! p_module_loaded="${module_loaded:-}" resolve_with_info; then
        return 1
    fi
    unset isolation_modules module_loaded


    LOGLEVEL=DEBUG log "=== resolve ???-$target ==="
    LOGLEVEL=DEBUG logtable "$TABLE"

    # generate final rcfile
    if ! execute_envdef "$TABLE" "$target" > "$RCFILE_PATH"; then
        return 1
    fi
    chmod 755 "$RCFILE_PATH"

    # fast_table_subset bound
    # fast_as_value
    # boundfiles=$TABLE_AS
    # # echo "$boundfiles"
    # unset TABLE_SUBSET TABLE_AS

    # filter table finally
#     PAST_TABLE=$TABLE
#     TABLE=
#     boundfiles=
#     OLDIFS=$IFS
#     IFS=$tab
#     while read -r ctype key value; do
#         case "$ctype$tab$key" in
#             VAR"${tab}"bound)
#                     boundfiles="${boundfiles}${boundfiles:+$newl}$value"
#                 ;;
#             VAR"${tab}"*'.'*|"$tab"|VAR"${tab}shell"|VAR"${tab}module")
#                     :
#                 ;;
#             *)
#                     out_var_just "$key" "$value" "$ctype"
#                 ;;
#         esac
#     done <<EOF
# $PAST_TABLE
# EOF
#     IFS=$OLDIFS

    # generate final rcfile
    # if ! PAST_TABLE="$PAST_TABLE" \
    #      execute_envdef "$TABLE" "$target" > "$RCFILE_PATH"; then
    #     _error "execute_envdef failed"
    #     return 1
    # fi

    # _debug "RC DONE"
    # chmod 755 "$RCFILE_PATH"
    # echo "$boundfiles"
}



get_rcfile_from_profiles_usecache() {
    # input:
    #   (X)ENVE_PROFILE
    #   ENVE_ROLES
    #   (X)ENVE_CONFIG
    #   ENVE_CONFIG_TEXT
    # output:
    #   rcfile path

    # fast_system_roles
    # s="${ENVE_ROLES},${out_system_roles}"
    s=$ENVE_ROLES
    replace "@" ","
    roles=${s%%,}
    unset s

    ENVE_CONFIG_TEXT="$ENVE_CONFIG${newl}inherit=$ENVE_PROFILE"

    mkrcfile() {
        if ! roles=$roles \
             ENVE_CONFIG_TEXT="$ENVE_CONFIG_TEXT" \
             RCFILE_PATH="$1" \
             get_rcfile_from_profiles_nocache; then
                return 1
        fi
    }


    if [ "${ENVE_CACHE_DIR:-}" != "nocache" ]; then
        p_text() {
            printf %s\\n "v20190308v1"
            printf %s\\n "$roles"
            printf %s\\n "$ENVE_CONFIG_TEXT"
        }

        p_vaild() {
            fast_readtext "$CACHED/boundfiles" || {
                _trace F1
                return 0
            }
            boundfiles="$text"
            boundhashes=$(files_stats_by_liens "$boundfiles") || {
                _trace F2
                return 0
            }
            fast_readtext "$CACHED/hashes" || {
                _trace F3
                return 0
            }
            excepted_boundhashes="$text"
            [ "$boundhashes" = "$excepted_boundhashes" ] || {
                _trace F4
                return 0
            }
            [ -s "$CACHED/rcfile" ] || {
                _trace F5
                return 0
            }
            echo 1
        }
        p_make() {
            mkrcfile "$CACHED/rcfile"
            fast_table_subset bound
            fast_as_value
            boundfiles=$TABLE_AS
            boundhashes=$(files_stats_by_liens "$boundfiles")
            _trace "profile: $ENVE_PROFILE"
            _trace "write to: $CACHED/boundfiles"
            echo "$boundfiles" > "$CACHED/boundfiles"
            echo "$boundhashes" > "$CACHED/hashes"
        }
        RCFILE_PATH=$(settrace
            catalog=boundfile cache_path "rcfile" p_text p_make p_vaild
            echo "$cached_path")
        d=$RCFILE_PATH
        fast_dirname
        BOUNDFILE_PATH="$d/boundfiles"
    else
        if ! tmprcfile="$(mkstemp ${TMPDIR:-/tmp}/rcfile.XXXXXX)"; then
            _error "failed to create tempfile"
            return 1
        fi
        mkrcfile "$tmprcfile"
        RCFILE_PATH=$tmprcfile
        BOUNDFILE_PATH=
    fi
    unset roles
}


fire() {
    #
    # pass
    #  ENVE_FIRE_DEPTH
    #  ENVE_CACHED_OS
    #  ENVE_CACHE_DIR
    #  ENVE_READLINK
    #
    # input
    #   [MODULE_OPTION]
    #   [ENVE_CONFIG_TEXT]
    #   [ENVE_ROLES]
    #

    target=$1
    shift
    ENVE_FIRE_DEPTH="$((${ENVE_FIRE_DEPTH:--1} + 1))"
    LOGTYPE=fire _info "level $ENVE_CACHED_OS $ENVE_FIRE_DEPTH $target $*"

    fast_get_system
    export ENVE_CACHED_OS

    ensure_readlink_command
    export ENVE_CACHE_DIR

    if [ -z "${ENVE_CACHE_DIR:-}" ]; then
        ENVE_CACHE_DIR=$(get_cachedir)
    fi
    export ENVE_READLINK

    MODULE_OPTION="${MODULE_OPTION:-};"
    if [ -z "${MODULE_OPTION%%*native_exec=1;*}" ]; then
        # direct execute without rcfile
        RCFILE_PATH=$1
        shift
        if [ -z "${MODULE_OPTION%%*source_exec=1;*}" ]; then
            sh_module=1
        fi
    else
        # get_rcfile_from_profiles
        fast_system_roles
        ENVE_ROLES="${target}${ENVE_ROLES:+,}${ENVE_ROLES},${out_system_roles}" \
        get_rcfile_from_profiles_usecache
        if [ -z "$RCFILE_PATH" ]; then
            return 1
        fi

        # while read -r line; do
        #     case $line in
        #         # TODO: use other config key
        #         # *"; export SHELL")
        #         #         cuts=${line%\'; export SHELL}
        #         #         invoke_shell=${cuts#*SHELL=\'}
        #         #     ;;
        #         # TODO: use other config key
        #         # *"; export ENVE_TERMINAL")
        #         #         cuts=${line%\'; export ENVE_TERMINAL}
        #         #         invoke_termainal=${cuts#*ENVE_TERMINAL=\'}
        #         #     ;;
        #         # TODO: BYPASS, BYPASS_FROM_UPSTREAM, BYPASS_TO_DOWNSTREAM
        #         # *"; export BYPASS")
        #         #         cuts=${line%\'; export BYPASS}
        #         #         invoke_bypass=${cuts#*BYPASS=\'}
        #         #     ;;
        #         \#"META: VAR$tab"*)
        #                 cuts=${line#\#"META: VAR$tab"}
        #                 key=${cuts%%$tab*}
        #                 s=${cuts#*$tab}
        #                 replace "${feed}" "${newl}"
        #                 value=$s
        #                 case $key in
        #                     SHELL)              invoke_shell=$value ;;
        #                     BYPASS)             invoke_bypass=$value ;;
        #                     PRJ_NAME)           PRJ_NAME=$value ;;
        #                     isolation.exec)     isoexec=$value ;;
        #                     isolation.options)
        #                             # TODO:
        #                             # shellcheck disable=2034
        #                             isooptions=$value
        #                         ;;
        #                     # isolation.enve)
        #                     #         isoenve=$value
        #                     #     ;;
        #                 esac
        #             ;;
        #     esac
        # done < "$RCFILE_PATH"

        rcfile_parse_meta_table "$RCFILE_PATH"
        while IFS="$tab" read -r key value; do
            case $key in
                isolation.exec)     isoexec=$value ;;
                isolation.options)
                        # TODO:
                        # shellcheck disable=2034
                        isooptions=$value
                    ;;
                # isolation.enve)
                #         isoenve=$value
                #     ;;
            esac
        done <<EOF
$META_TABLE
EOF

    fi

    # this is for $ENVE_PROGRESS
    # if [ "${ENVE_FIRE_DEPTH}" -eq 0 ]; then
    #     echo "" >&2
    # fi

    exec_isoexec() {
        if [ -z "${isoexec:-}" ]; then
            _fatal "no isolation is specficed"
        fi

        d=$isoexec
        fast_dirname
        ZERO=$d
        unset d

        # PRJ_NAME=$PRJ_NAME \
        # target=$target \
        # invoke_shell=$invoke_shell \
        # invoke_termainal="${invoke_termainal:-}" \
        # bypass_envs=$bypass_envs \
        ZERO=$ZERO \
        ENVE_HOME=$ENVE_HOME \
        EXTRA_ENVS="ENVE_FIRE_DEPTH='$ENVE_FIRE_DEPTH'${EXTRA_ENVS:+ $EXTRA_ENVS}" \
        EXTRA_TARGET=${EXTRA_TARGET:-} \
        RCFILE_PATH=$RCFILE_PATH \
        exec "$isoexec" "$@"
    }

    _notice "enter $RCFILE_PATH"

    case $target in
        shell|run|terminal)
                exec_isoexec "$@"
            ;;
        test)
                # bypass_envs="$bypass_envs ENVE_HOME='$ENVE_HOME'"
                EXTRA_TARGET=run EXTRA_ENVS="ENVE_HOME='$ENVE_HOME'" exec_isoexec "$@"
            ;;
        build|setup)
                # bypass_envs="${bypass_envs:+$bypass_envs }PRJ_OUT='xxxTODO'"
                EXTRA_TARGET=run EXTRA_ENVS="PRJ_OUT='xxxTODO'" exec_isoexec "$@"
            ;;
        loader|module)
                if [ -n "${sh_module:-}" ]; then
                    # shellcheck disable=1090
                    . "$RCFILE_PATH"
                    # shellcheck disable=1090
                    main "$@"
                else
                    exec_isoexec "$@"
                fi
                # if [ "$target" = "module" ] && [ -f "${BOUNDFILE_PATH:-}" ]; then
                #     while read -r bound; do
                #         out_var_fast bound "$bound"
                #     done < "$BOUNDFILE_PATH"
                # fi
            ;;
        execute)
            ;;
    esac
}

enve_fire() {
    fire "$@"
}



