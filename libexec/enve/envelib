#!/usr/bin/env bash

# shellcheck disable=2016
true

if [ -n "${HAVE_ENVE_ENVELIB:-}" ]; then
    return 0
fi
HAVE_ENVE_ENVELIB=1

# shellcheck source=libexec/enve/base
. "$ENVE_HOME/enve/base"
# shellcheck source=libexec/enve/findutils
. "$ENVE_HOME/enve/findutils"
# shellcheck source=libexec/enve/pathutils
. "$ENVE_HOME/enve/pathutils"
# shellcheck source=libexec/enve/cachelib
. "$ENVE_HOME/enve/cachelib"
# shellcheck source=libexec/enve/urlutils
. "$ENVE_HOME/enve/urlutils"

tab="$(printf '\tx')"
tab="${tab%x}"
feed="$(printf '\fx')"
feed="${feed%x}"
vtab="$(printf '\vx')"
vtab="${vtab%x}"
newl="$(printf '\nx')"
newl="${newl%x}"


# All function in this definition are design to compatible with posix shell.
# External Dependencies are awk(1), tr(1), pwd(1), ls(1), basename(1), dirname(1).
#
# The newline character in VALUE will be replaced to '\f' before store in table.
# Therefore VALUE can store any ascii character except '\f'
#
# table syntax:
#   TABLE   = (ENTRY '\n')*
#   ENTRY   = VTYPE '\t' KEY '\t' VALUE
#   KEY     = KEYCOMP ('.' KEYCOMP)*
#   VTYPE   = 'VAR' | 'RVAR' | 'FUNC' | 'ALIAS' | 'LIST' | 'JOIN' | 'SRC'
#   KEYCOMP = [^\n.]+
#   VALUE   = [^\n]*



# table_tail() {
#     vtype="${2:-VAR}"
#     echo "$TABLE" | grep -E "^${vtype}${tab}${1}${tab}" | tail -n 1 | cut -d"${tab}" -f3-
# }



_fast_table_match() {
    _key_cond=$1
    _inverse=${inverse:-}

    _sh_regex=
    _grep_regex=

    s=${_key_cond}
    replace '\.' 'z'
    _search_regex_symbol=$s
    _search_regex_symbol=${_search_regex_symbol%".*"}
    if      [ "${_search_regex_symbol#*[\*\.\+\?\[\]\(\)\{\}\^\$\|]}" = "${_search_regex_symbol}" ]; then
        s=${_key_cond}
        replace '.*' '*'
        _sh_regex=${s}
    else
        _grep_regex=${_key_cond}
    fi

    matchlines=
    if [ -n "${_sh_regex}" ]; then
        # fast prefix match
        while IFS="" read -r line; do
            mline=${line%${tab}*}
            if [ -z "${mline%$vtype$tab${_sh_regex}}" ]; then
                match=1
            else
                match=
            fi
            # echo "${_inverse} + ${match}: $_sh_regex : $mline : ${mline#$vtype$tab${_sh_regex}}" >&2
            if      { [ -n "${_inverse}" ] && [ -z "${match}" ]; } || \
                    { [ -z "${_inverse}" ] && [ -n "${match}" ]; }; then
                matchlines="${matchlines}$line$newl"
            fi
        done <<EOF
$TABLE
EOF
    else
        # regex match
        matchlines=$(printf %s\\n "$TABLE" | grep -E ${_inverse:+-v} \
                     "^${vtype}${tab}${_grep_regex}${tab}" || true)
    fi
    unset _key_cond _sh_regex _grep_regex _inverse _search_regex_symbol s line mline
}


fast_table_tail() {
    vtype="${2:-VAR}"
    _fast_table_match "$1"
    v=${matchlines%%$newl}
    v=${v##*$newl}
    v=${v#$vtype$tab*$tab}
    if [ -z "$v" ]; then
        v=${TABLE_DEFAULT:-}
    fi
    TABLE_TAIL=$v
    unset matchlines v
}


fast_table_subset() {
    vtype="${2:-VAR}"
    _fast_table_match "$1"
    kv=
    while read -r line; do
        if [ -n "$line" ]; then
            kv="${kv}${line#$vtype$tab}$newl"
        fi
    done <<EOF
$matchlines
EOF
    # TABLE_SUBSET=${kv%%$newl}
    TABLE_SUBSET=$kv
    unset matchlines line
}

fast_table_exclude() {
    vtype="${2:-VAR}"
    inverse=1 _fast_table_match "$1"
    kv=
    while read -r line; do
        if [ -n "$line" ]; then
            kv="${kv}${line#$vtype$tab}$newl"
        fi
    done <<EOF
$matchlines
EOF
    # TABLE_SUBSET=${kv%%$newl}
    TABLE_SUBSET=$kv
    unset matchlines line
}

table_tail() {
    vtype="${2:-VAR}"
    fast_table_tail "$@"
    printf %s\\n "$TABLE_TAIL"
    unset vtype
}

table_subset() {
    vtype="${2:-VAR}"
    fast_table_subset "$@"
    printf %s "$TABLE_SUBSET"
    unset vtype
}

table_exclude() {
    vtype="${2:-VAR}"
    fast_table_exclude "$@"
    printf %s "$TABLE_SUBSET"
    unset vtype
}







# _table_match() {
#     if [ "${1#*\*}" = "$1" ] && [ "${1#*\.}" = "$1" ]; then
#         # fast prefix match
#         while IFS="" read -r line; do
#             # echo "L: x_${line}_x" >&2
#             if [ "${line#$vtype$tab$1$tab}" != "$line" ]; then
#                 printf %s\\n "$line"
#             fi
#         done <<EOF
# $TABLE
# EOF
#     else
#         # regex match
#         printf %s\\n "$TABLE" | grep -E "^${vtype}${tab}${1}${tab}" || true
#     fi
# }

# table_tail() {
#     vtype="${2:-VAR}"
#     _val=
#     while IFS="" read -r line; do
#         if [ -n "$line" ]; then
#             _val=${line#$vtype$tab*$tab}
#         fi
#     done <<EOF
# $(_table_match "$1")
# EOF

#     if [ -n "${_val}" ]; then
#         printf %s\\n "${_val}"
#     elif [ -n "${TABLE_DEFAULT:-}" ]; then
#         printf %s\\n "${TABLE_DEFAULT}"
#     fi
#     unset vtype line _val
# }

# # table_subset() {
# #     vtype="${2:-VAR}"
# #     echo "$TABLE" | grep -E "^${vtype}${tab}${1}${tab}" | cut -d"${tab}" -f2-
# # }

# table_subset() {
#     vtype="${2:-VAR}"
#     while IFS="" read -r line; do
#         if [ -n "$line" ]; then
#             printf %s\\n "${line#$vtype$tab}"
#         fi
#     done <<EOF
# $(_table_match "$1")
# EOF
#     unset vtype line
# }

# table_exclude() {
#     vtype="${2:-VAR}"
#     echo "$TABLE" | grep -E -v "^${vtype}${tab}${1}${tab}" | cut -d"${tab}" -f2-
# }

# shellcheck disable=2120,2031
value_substi() {
    _cur="${_value}"
    # echo "value_substi ${_cur}" >&2
    _PASSVARS="$newl${PASSVARS:-}$newl"
    _newvalue=
    while [ "${_cur%\$\{*\}*}" != "${_cur}" ]; do

        # in case of '123${variable}456'
        #   _left   = '123'
        #   _center = 'variable'
        #   _right  = '456'
        _left=${_cur%%\$\{*\}*}
        _right=${_cur#*\$\{*\}}
        _center=${_cur%\}"${_right}"}
        _center=${_center#"$_left"\$\{}
        # echo "${_left}--${_center}--${_right}" >&2
        if [ "${_left#${_left%?}}" = "\\" ]; then
            _newvalue="${_newvalue}${_left%?}\${${_center}}"
            _cur=${_right}
            continue
        fi
        if [ "${_center%${_center#?}}" = "_" ]; then
            _newvalue="${_newvalue}${_left}\${${_center}}"
            _cur=${_right}
            continue
        fi
        if [ "${_center#*:[-+=]}" != "${_center}" ]; then
            _namepart=${_center%%:[-+=]*}
            _recpart=${_center#*:[-+=]}
        elif [ "${_center#*[-+=]}" != "${_center}" ]; then
            _namepart=${_center%%[-+=]*}
            _recpart=${_center#*[-+=]}
        else
            _namepart=${_center}
            _recpart=
        fi

        # echo "R:${_recpart:-}" >&2
        # echo "N:${_namepart}" >&2
        # echo "C:${_center}" >&2
        if [ -n "${_namepart}" ] && [ "${_namepart#*\$}" = "${_namepart}" ] && \
                                    [ "${_recpart#*\$\(}" = "${_recpart}" ]; then
            if [ "${_PASSVARS#*$newl$_namepart$newl}" = "${_PASSVARS}" ]; then
                eval _center=\$\{"${_center}"\}
            else
                # output the "'" escape form
                _center="'\"\${${_center}}\"'"
            fi
        else
            error "unsafe variable subsitution"
            return 1
        fi

        _newvalue="${_newvalue}${_left}${_center}"
        _cur=${_right}
    done
    _newvalue="${_newvalue}${_cur}"
    if [ "${1:-}" != nonfast ]; then
        _subsited_value=${_newvalue}
        # _value=${_newvalue}
    else
        # echo "${_newvalue}" >&2
        printf %s\\n "${_newvalue}"
    fi
}


table_substi() {
    # table values substitution
    (
        _table=$1
        vtypes=",${2:-VAR,LIST},"
        # use "$1" as variable table to make context
        while IFS="${tab}" read -r _vt _vk _value; do
            if [ "${_vt}" = "VAR" ] && [ "${_vk%\.*}" = "${_vk}" ]; then
                value_substi
                eval "${_vk}=\"\${_subsited_value}\""
            fi
        done <<EOF
$_table
EOF

        while IFS="${tab}" read -r _vt _vk _value; do
            if [ "${vtypes%,${_vt},*}" != "${vtypes}" ]; then
                value_substi
                _value=${_subsited_value}
            fi
            printf %s\\n "${_vt}${tab}${_vk}${tab}${_value}"
        done <<EOF
$TABLE
EOF
    )
}


fast_as_postfix() {
    _postfix=$1
    TABLE_AS=
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ]; then
            TABLE_AS="${TABLE_AS}${name#${_postfix}}${tab}${value}$newl"
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    unset _postfix name value
}

fast_as_rootkey() {
    TABLE_AS=
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ]; then
            TABLE_AS="${TABLE_AS}${name%.*}${tab}${value}$newl"
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    unset _postfix name value
}

fast_as_value() {
    TABLE_AS=
    while IFS="${tab}" read -r name value; do
        if [ -n "$value" ]; then
            TABLE_AS="${TABLE_AS}$value$newl"
        else
            TABLE_AS=
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    unset name value
}


fast_as_tail() {
    fast_as_value
    TABLE_AS=${TABLE_AS%%$newl*}
    if [ -z "$TABLE_AS" ]; then
        TABLE_AS=${TABLE_DEFAULT:-}
    fi
}

fast_as_uniquekey() {
    TABLE_AS="$newl"
    while IFS="${tab}" read -r name value; do
        if [ -n "$name" ] && [ "${TABLE_AS%$newl$name$newl*}" = "${TABLE_AS}" ]; then
            TABLE_AS="${TABLE_AS}${name}${newl}"
        fi
    done <<EOF
$TABLE_SUBSET
EOF
    TABLE_AS="${TABLE_AS#$newl}"
    # TABLE_AS="${TABLE_AS%$newl}"
    unset name value
}

fast_as_concat() {
    concat_by="${1:-}"
    fast_as_value
    if [ "$concat_by" != "$newl" ]; then
        s=$TABLE_AS
        replace "$newl" "$concat_by"
        TABLE_AS=$s
    fi
    TABLE_AS=${TABLE_AS%$concat_by}
    unset concat_by s
}

as_postfix() {
    TABLE_SUBSET=$(cat -) fast_as_postfix "$1"
    printf %s "$TABLE_AS"
}
as_rootkey() {
    TABLE_SUBSET=$(cat -) fast_as_rootkey
    printf %s "$TABLE_AS"
}
as_value() {
    TABLE_SUBSET=$(cat -) fast_as_value
    printf %s "$TABLE_AS"
}
as_uniquekey() {
    TABLE_SUBSET=$(cat -) fast_as_uniquekey
    printf %s "$TABLE_AS"
}
as_concat() {
    TABLE_SUBSET=$(cat -) fast_as_concat "$1"
    printf %s "$TABLE_AS"
}






# as_postfix() {
#     while IFS="${tab}" read -r name value; do
#         echo "${name#$1}${tab}${value}"
#     done
# }

# as_rootkey() {
#     while IFS="${tab}" read -r name value; do
#         echo "${name%.*}${tab}${value}"
#     done
# }

# as_value() {
#     _list=
#     while IFS="${tab}" read -r name value; do
#         if [ -n "$value" ]; then
#             # echo "$value"
#             _list="${_list}${_list:+$newl}$value"
#         else
#             _list=
#         fi
#     done
#     if [ -n "${_list}" ]; then
#         printf %s\\n "${_list}"
#     fi
#     unset name value _list
# }

# as_uniquekey() {
#     keys="$newl"
#     while IFS="${tab}" read -r name value; do
#         # if [ -n "$name" ] && [ "${keys/$name$newl/}" = "${keys}" ]; then
#         if [ -n "$name" ] && [ "${keys%$newl$name$newl*}" = "${keys}" ]; then
#             keys="${keys}${name}${newl}"
#         fi
#     done
#     keys="${keys#$newl}"
#     echo "${keys%$newl}"
#     unset keys
# }

# as_concat() {
#     concat="${1:-}"
#     # as_value | (c="$(cat)"; printf %s "${c%%$newl}") | {
#     s=$(as_value)
#     # s=${s%%$newl}
#     if [ "$concat" = "$newl" ]; then
#         printf %s\\n "$s"
#     elif [ -n "$concat" ]; then
#         # printf %s "${v%%$newl}" | tr "$newl" "$concat"
#         replace "$newl" "$concat"
#         printf %s\\n "$s"
#     else
#         # printf %s "${v%%$newl}" | tr -d "$newl"
#         replace "$newl" ""
#         printf %s\\n "$s"
#     fi
# }











resolve_path() {
    # path in config file should relative to project root (layout.root)
    if [ -z "$1" ]; then
        return
    fi
    if [ "${1%"${1#?}"}" = '/' ]; then
        echo "$1"
        return
    fi
    if [ -z "${root:-}" ]; then
        root=$(table_tail layout.root)
    fi
    if [ -z "${root:-}" ]; then
        root="${PRJROOT:-}"
    fi
    if [ -z "$root" ]; then
        root="${CONFIGROOT:-}"
    fi
    if [ -z "$root" ]; then
        root="$(pwd)"
    fi
    echo "${root%/}/$1"
    unset root
}

out_var() {
    # echo "VAR${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
    echo "VAR${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_var_fast() {
    printf %s\\n "VAR${tab}$1${tab}$2"
}
out_var_just() {
    TABLE="${TABLE}${newl}${3:-VAR}${tab}$1${tab}$2"
}

# out_module() {
#     printf %s\\t%s\\t%s\\n "$1" "$2" "$3"
# }
# out_rawvar() {
#     # echo "RVAR${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
#     echo "RVAR${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
# }

# out_func() {
#     # TODO: types $2
#     # funcbody="${2##*()}"
#     # echo "FUNC${tab}$1${tab}$(printf "%s" "$funcbody" | tr '\n' '\f')"
#     # unset funcbody
#     echo "FUNC${tab}$1${tab}$(s=${2##*()}; replace "$newl" "$feed"; printf "%s" "$s")"
# }

out_alias() {
    # echo "ALIAS${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
    echo "ALIAS${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_list() {
    # echo "LIST${tab}$1${tab}$(printf "%s" "$2" | tr '\n' '\f')"
    echo "LIST${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_join() {
    echo "JOIN${tab}$1${tab}$2"
}
out_source() {
    echo "SRC${tab}$1${tab}$2"
}
out_code() {
    echo "CODE${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}
out_secret() {
    echo "SEC${tab}$1${tab}$(s=$2; replace "$newl" "$feed"; printf "%s" "$s")"
}

system_roles() {
    # out=
    # if [ -n "${MSYSTEM:-}" ]; then
    #     out="$out${out:+,}msystem,nt"
    #     case $MSYSTEM in
    #         MINGW32) out="$out${out:+,}mingw32"; ;;
    #         MINGW64) out="$out${out:+,}mingw64"; ;;
    #         MSYS2) out="$out${out:+,}msys2"; ;;
    #         CYGWIN) out="$out${out:+,}cygwin,posix"; ;;
    #     esac
    # fi
    # case $(uname) in
    #     FreeBSD) out="$out${out:+,}freebsd,bsd,unix,posix"; ;;
    #     Darwin) out="$out${out:+,}darwin,bsd,unix,posix"; ;;
    #     Linux) out="$out${out:+,}linux,unix,posix"; ;;
    # esac
    out=
    fast_get_system
    case "$ENVE_CACHED_OS" in
        FreeBSD) out="$out${out:+,}freebsd,bsd,unix,posix"; ;;
        Darwin) out="$out${out:+,}darwin,bsd,unix,posix"; ;;
        Linux) out="$out${out:+,}linux,unix,posix"; ;;
        MINGW32) out="$out${out:+,}nt,msystem,mingw,mingw32"; ;;
        MINGW64) out="$out${out:+,}nt,msystem,mingw,mingw64"; ;;
        MSYS*) out="$out${out:+,}nt,msystem,msys2"; ;;
        CYGWIN) out="$out${out:+,}nt,cygwin,posix"; ;;
    esac
    echo "$out"
    out=
}


_parse_keyvalue() {
    line="$1"

    key=
    if [ "${line##*^=}" = "${line}" ]; then
        value="${line##*=}"
        if [ "$value" != "$line" ]; then
            key="${line%%=*}"
        fi
    else
        # value="${line//^=/=}"
        value=$(printf %s "$line" | sed 's/\^=//g')
    fi

    # key="${key##+([[:space:]])}"
    # key="${key%%+([[:space:]])}"
    if [ -n "$key" ]; then
        junk=${key%%[![:space:]]*}
        key=${key#"$junk"}
        junk=${key##*[![:space:]]}
        key=${key%"$junk"}
    fi
    # echo "P:'$line' $key='$value'" >&2
}



parse_config_recursive() {

    config_path="$(
            canonicalize_symlinks "$1")" || {
        warning "WARNING: not a resolvable path '$1'"
        return
    }


    # echo "loading $config_path" >&2
    [ -f "$config_path" ] || {
        warning "WARNING: no such config file $config_path"
        return
    }
    loaded=${loaded:-$newl}
    if [ "${loaded#$newl$config_path$newl}" != "$loaded" ]; then
        return
    fi

    # root_path="$(canonicalize_symlinks "$(dirname "$config_path")")"
    # root_path="$(dirname "$config_path")"
    # root_path="$(canonicalize_symlinks "$(dirname "$1")")"
    d="$1"
    fast_dirname
    root_path=$(canonicalize_symlinks "$d")

    # if grep "$config_path" < "$LOADED_RECORD"; then
    #     # echo "LOADED $config_path" >&2
    #     return
    # fi
    # trace "parsing [roles: ${roles}] ${config_path}"


    filter_roles() {
        s="$key${newl}"
        replace "," "@"
        _roles=,$roles
        IFS=','
        for role in ${_roles}; do
            replace "@$role@" "@"
            replace "@$role." "."
            replace "@$role$newl" "$newl"
        done
        key=$s
        key="${key%$newl}"
        key="${key%\.}"
        # echo "$key"
    }
    # is_roles_pass() {
    #     # [ "$1" = "${1//[@,]/}" ]
    #     [ "$1" = "${1%%[@,]*}" ]
    # }
    emit() {
        # key="$(filter_roles "$1")"
        key="$1"
        value="$2"
        # filter_roles
        # if is_roles_pass "$key"; then
        if [ "$key" = "${key%%@*}" ]; then
            printf VAR\\t%s\\t%s\\n "$key" "$value"
        fi
    }

    out_var_fast layout.root "$root_path"

    loaded="$loaded$config_path$newl"
    stab=
    stabkey=
    while IFS="${newl}" read -r line; do
        # line="${line##+([[:space:]])}"
        # line="${line%%+([[:space:]])}"
        junk=${line%%[![:space:]]*}
        line=${line#"$junk"}
        junk=${line##*[![:space:]]}
        line=${line%"$junk"}
        # [ -z "$line" ] || [ "${line:0:1}" = ";" ] || [ "${line:0:1}" = "#" ] && continue
        { [ -z "$line" ] || [ "${line%"${line#?}"}" = ";" ] || [ "${line%"${line#?}"}" = "#" ]; } && continue

        if [ -n "$stab$stabkey" ]; then
            # if [ "${line: -1}" = '\' ] && [ "${line: -2}" != '\\' ]; then
            #     stab="${stab}${line:0: -1}"
            # else
            if [ "${line#"${line%?}"}" = "\\" ] && [ "${line#"${line%??}"}" != "\\\\" ]; then
                stab="${stab}${line%?}"
            else
                # [ "${line: -2}" = '\\' ] && line="${line%\\}"
                [ "${line#"${line%??}"}" = "\\\\" ] && line="${line%\\}"

                stab="${stab}${line}"
                # echo "VAR${tab}"${stabkey}"${tab}"${stab}
                emit "$stabkey" "$stab"
                stabkey=
                stab=
            fi
        else
            # if [ "${line:0:1}" = '[' ] && [ "${line: -1}" = ']' ]; then
            #     new_area="${line:1:-1}"
            if [ "${line%"${line#?}"}" = '[' ] && [ "${line#"${line%?}"}" = ']' ]; then
                new_area="${line#\[}"
                new_area="${new_area%\]}"

                # Note: original key should not contain character '@' or ',', otherwise role test failed
                # new_area="${new_area##+([[:space:]])}"
                # new_area="${new_area%%+([[:space:]])}"
                junk=${new_area%%[![:space:]]*}
                new_area=${new_area#"$junk"}
                junk=${new_area##*[![:space:]]}
                new_area=${new_area%"$junk"}

                area="$new_area"
                # if [ -n "${new_area}" ]; then
                #     new_area="$(filter_roles "${new_area}")"
                #     # Note: area should not contain character '-', otherwise role test failed
                #     if [ "${new_area}" != "${new_area//-/}" ]; then
                #         new_area=
                #     fi
                #     if [ -n "${new_area}" ]; then
                #         area="$new_area"
                #     fi
                # fi
            else
                # import (Deprecated) == include
                if [ "${area}" = "import" ] || [ "${area}" = "include" ] || [ "${area}" = "inherit" ]; then
                    # TODO: not resolve, only normalize path
                    innerfile=$(root="$root_path" resolve_path "$line")
                    if ! innertable=$(
                                settrace
                                parse_config_recursive "$innerfile"); then
                        error "parse error at $innerfile"
                        return 1
                    fi
                    while IFS="$tab" read -r vtype key value; do
                        if [ "$key" = "enve.configs" ]; then
                            if [ "${loaded#$newl$value$newl}" != "$loaded" ]; then
                                loaded="$loaded$value$newl"
                                printf %s\\t%s\\t%s\\n "$vtype" "$key" "$value"
                            fi
                        elif [ "$key" = "layout.root" ] && [ "${area}" != "inherit" ]; then
                            :
                        else
                            printf %s\\t%s\\t%s\\n "$vtype" "$key" "$value"
                        fi
                    done <<EOF
$innertable
EOF
                elif [ "${area}" = "comment" ]; then
                    :;
                elif [ -n "${area}" ]; then
                    # key=
                    # if [ "${line##*^=}" = "${line}" ]; then
                    #     value="${line##*=}"
                    #     if [ "$value" != "$line" ]; then
                    #         key="${line%%=*}"
                    #     fi
                    # else
                    #     value="${line/^=/=}"
                    # fi
                    # key="${key##+([[:space:]])}"
                    # key="${key%%+([[:space:]])}"
                    _parse_keyvalue "$line"


                    # if [ "${value: -1}" = '\' ] && [ "${value: -2}" != '\\' ]; then
                    #     stabkey="${area}${key:+.}${key}"
                    #     stab="${stab}${value:0: -1}"
                    # else
                    if [ "${value#"${value%?}"}" = "\\" ] && [ "${value#"${value%??}"}" != "\\\\" ]; then
                        stabkey="${area}${key:+.}${key}"
                        stab="${stab}${value%?}"
                    else
                        # [ "${value: -2}" = '\\' ] && value="${value%\\}"
                        [ "${value#"${value%??}"}" = "\\\\" ] && value="${value%\\}"
                        emit "${area}${key:+.}${key}" "$value"
                        # echo "VAR${tab}"${area}${key:+.}${key}"${tab}"${value}
                    fi
                fi
            fi
        fi
    done < "$config_path"

    out_var_fast bound "$config_path"
    out_var_fast enve.configs "$config_path"
    out_var_fast enve.roles "$roles"

    # echo "$config_path" >> "$LOADED_RECORD"
}

parse_config() {
    # LOADED_RECORD="$(mktemp)"
    for cfg in "$@"; do
        roles="${roles:-}${roles:+,}$(system_roles)" parse_config_recursive "$cfg"
    done
    # rm $LOADED_RECORD >/dev/null
}

enve_parse_config() {
    # LOADED_RECORD="$(mktemp)"
    _trace enve_parse_config
    OLDIFS=$IFS
    IFS=','
    # for cfile in $(IFS=','; echo $ENVE_PROFILE); do
    for cfile in $ENVE_PROFILE; do
        IFS=$OLDIFS
        if [ -n "$cfile" ]; then
            # echo "cfile: $cfile" >&2
            roles="${ENVE_ROLES}${ENVE_ROLES:+,}$(system_roles)" parse_config_recursive "$cfile"
        fi
    done
    if [ -n "$ENVE_CONFIG" ]; then
        echo "$ENVE_CONFIG"
    fi
    # rm $LOADED_RECORD >/dev/null
}


variable_action() {
    case $name in
        # PRJ_NAME)
        #         if [ -n "$r_value" ] && [ "$target" = "shell" ] && [ "$UNAME_S" = "Darwin" ]; then
        #             eval_line 'OLD_PRJ_NAME="$PRJ_NAME"'
        #             eval_line "printf '\\033]0;%s\\007' '$r_value'"
        #             exithook="${exithook}${exithook:+$newl}  printf '\\033]0;%s\\007' \"\$OLD_PRJ_NAME\""
        #         fi
        #     ;;
        TERMSIZE)
                if [ -n "$r_value" ] && [ "$target" = "shell" ] && [ -x "/usr/bin/tput" ]; then
                    # echo -e -n "\033[8;10;140t"
                    width="${r_value%%x*}"
                    height="${r_value##*x}"
                    eval_line "OLD_COLUMNS=\$(/usr/bin/tput cols)"
                    eval_line "OLD_LINES=\$(/usr/bin/tput lines)"
                    # eval_line "echo -e -n \"\\033[8;${height};${width}t\""
                    # exithook="${exithook}${exithook:+$newl}  echo -e -n \"\\033[8;\${OLD_LINES};\${OLD_COLUMNS}t\""
                    eval_line "printf '\\033[8;%s;%st' \"${height}\" \"${width}\""
                    exithook="${exithook}${exithook:+$newl}  printf '\\033[8;%s;%st' \"\${OLD_LINES}\" \"\${OLD_COLUMNS}\""
                fi
            ;;
        TERMTHEME)
                if [ -n "$r_value" ] && [ "$target" = "shell" ] && [ "$UNAME_S" = "Darwin" ]; then
                    eval_line 'OLD_TERMTHEME="$TERMTHEME"'
                    eval_line "$ENVE_HOME/enve/core/macos/term_theme.applescript '$r_value'"
                    exithook="${exithook}${exithook:+$newl}  $ENVE_HOME/enve/core/macos/term_theme.applescript \"\$OLD_TERMTHEME\""
                fi
            ;;
    esac
    # eval_line "$name='$(eval echo "$r_value")'; export $name"
    eval_line "$name='$r_value'; export $name"
}



execute_envdef() {
    TABLE="$1"
    target=$2
    shift 2
    TABLE=$(
            settrace
            table_substi "$TABLE"
    ) || return 1

    eval_line() {
        LOGLEVEL=DEBUG log "EVAL: $1"
        echo "$1"
    }
    _lists=
    exithook=
    while IFS="$tab" read -r vtype name value; do
        # r_value="$(echo "$value" | "$TREXEC" '\f' '\n')"
        r_value=$(s=$value; replace "$feed" "$newl"; replace "'" "'\\''"; printf %s "$s")
        case $vtype in
            VAR)
                    variable_action
                    # eval_line "$name='$(eval echo "$r_value")'; export $name"
                    # if [ "$name" = "PRJ_NAME" ] && [ "$(uname)" = "Darwin" ]; then
                    #     eval_line 'echo -n -e "\033]0;$PRJ_NAME\007"'
                    # fi
                ;;
            # RVAR)
            #         eval_line "$name='$r_value'; export $name"
            #     ;;
            LIST)
                    # eval "_LIST_$name='$(eval echo \$_LIST_$name)$(eval echo \$\{_LIST_$name:+\$_JOIN_$name\})$value'"
                    # eval_line "eval $name='$(eval echo "\$_LIST_$name")'; export $name"
                    if eval [ -z \""\$_JOIN_$name"\" ]; then
                        continue
                    fi
                    if [ -n "$r_value" ]; then
                        # eval eval echo "_LIST_$name='\${_LIST_$name}\${_LIST_$name:+\$_JOIN_$name}\$r_value'" >&2
                        eval eval "_LIST_$name='\${_LIST_$name}\${_LIST_$name:+\$_JOIN_$name}\$r_value'"
                    else
                        eval "_LIST_$name="
                    fi
                    # eval_line "$name='$(eval echo "\$_LIST_$name")'; export $name"
                ;;
            JOIN)
                    eval "_JOIN_$name='$value'; _LIST_$name=\"\${_LIST_$name:-}\""
                    _lists="${_lists}${_lists:+ }$name"
                    # eval_line "export $name=''"
                    # eval_line "export $name"
                ;;
            # FUNC)
            #         eval_line "$name() $r_value"
            #     ;;
            ALIAS)
                    eval_line "alias $name='$r_value'"
                ;;
            SRC)
                    eval_line ". '$r_value'"
                ;;
            CODE)
                    eval_line "$value"
                ;;
            SEC)
                    eval_line "$name=\$($r_value); export $name"
                ;;
            EXEC)
                    set -- "$@" "$r_value"
                ;;
            META)
                    eval_line "#META: VAR${tab}$name${tab}$value"
                ;;
        esac
    done <<EOF
$TABLE
EOF

    for name in ${_lists}; do
        # TODO: need test with variable subsitution
        if eval [ -n "\$_LIST_$name" ]; then
            eval_line "$name='$(eval printf %s\\\\n \""\$_LIST_$name"\")'; export $name"
        fi
    done

    cwd=$(TABLE=$PAST_TABLE table_tail exec.cwd)
    cwd=${cwd:-%cwd}
    if [ "$cwd" = "%cwd" ]; then
        :
    elif [ "${cwd%"${cwd#?????}"}" = "%root" ]; then
        # echo "%root" >&2
        # TABLE=$PAST_TABLE table_tail layout.root >&2
        eval_line 'cd "'"$(TABLE=$PAST_TABLE table_tail layout.root)${cwd#\%root}"'"'
    else
        eval_line 'cd "'"$cwd"'"'
    fi

    eval_line 'unset ENV'
    if [ "$target" = "shell" ]; then
        eval_line 'OLDIFS="$IFS"; IFS=":";'
        eval_line 'for opt in $ENVE_SHELLOPTS; do if [ "${opt#-}" = "$opt" ]; then set -o $opt; else set +o ${opt#-}; fi; done'
        eval_line 'if [ -n "${BASH_VERSION:-}" ]; then'
        eval_line ' for opt in $ENVE_BASHOPTS; do if [ "${opt#-}" = "$opt" ]; then shopt -s $opt; else shopt -u ${opt#-}; fi; done'
        eval_line 'elif [ -n "${ZSH_VERSION:-}" ]; then'
        eval_line ' setopt sh_word_split'
        eval_line ' for opt in $ENVE_ZSHOPTS; do if [ "${opt#-}" = "$opt" ]; then setopt $opt; else unsetopt ${opt#-}; fi; done'
        eval_line ' unsetopt sh_word_split'
        eval_line 'fi'
        eval_line 'IFS="$OLDIFS"'
        eval_line 'unset ENVE_SHELLOPTS'
        eval_line 'unset ENVE_BASHOPTS'
        eval_line 'unset ENVE_ZSHOPTS'
        eval_line 'if [ -n "${ENVE_RCRESOLVE_PIDFILE:-}" ]; then'
        eval_line '  _pid=$$'
        eval_line '  (set -o noclobber; '
        eval_line '   if ! { echo ${_pid} > "$ENVE_RCRESOLVE_PIDFILE"; } 2>/dev/null; then'
        eval_line '     echo "PIDFILE already exist, can not execute alone" >&2'
        eval_line '     exit 2'
        eval_line '   fi)'
        eval_line '  unset _pid'
        eval_line 'fi'
        eval_line 'unset ENVE_RCRESOLVE_PIDFILE'
        eval_line 'onexit() { '
        eval_line '  '"${exithook:-true}"
        eval_line '}'
        eval_line 'trap onexit INT TERM EXIT'
    elif [ "$target" = "test" ]; then
        eval_line '. $ENVE_HOME/enve/testlib'
        eval_line 'ENVE_TEST_OUTPUT=${ENVE_TEST_OUTPUT:-$(mkdtemp "$(get_tempdir)"/enve-test.XXXXXX)}; export ENVE_TEST_OUTPUT'
        eval_line 'TEST_OUTPUT=$ENVE_TEST_OUTPUT; export TEST_OUTPUT'
        eval_line 'CACHED=$TEST_OUTPUT harness '\\
        while IFS="$tab" read -r casename cmd; do
            if [ -n "$casename" ]; then
                eval_line '  "'"$casename"'" "'"$cmd"'" '\\
            fi
        done <<EOF
$(TABLE=$PAST_TABLE table_subset "test.jobs\\..*" | as_postfix "test.jobs\\.")
EOF
        eval_line '  ;'
    else
        # TODO: test this
        if [ $# -gt 0 ]; then
            eval_line 'case ${ENVE_CHAINEXEC_STAGE:-1} in '
            stage=1
            for execstmt in "$@"; do
                if [ "$stage" -eq $# ]; then
                    eval_line "  $stage) exec ${execstmt} \"\$@\";;"
                else
                    eval_line "  $stage) ENVE_CHAINEXEC_STAGE=$((stage + 1)) exec ${execstmt%__chain__*} sh \$0 \"\$@\" ${execstmt#*__chain__} ;;"
                fi
                stage=$((stage + 1))
            done
            eval_line 'esac'
        elif [ "$target" = "module" ] || [ "$target" = "loader" ]; then
            eval_line 'if [ -z "${sh_module:-}" ]; then'
            eval_line '  exec "$@"'
            eval_line 'fi'
        else
            eval_line 'exec "$@"'
        fi
    fi
    # eval_line
    # case ${ENVE_CHAINEXEC_STAGE:-1} in
    #     1) ENVE_CHAINEXEC_STAGE=2 exec aaa $0 ;;
    #     2) ENVE_CHAINEXEC_STAGE=3 exec bbb $0 ;;
    #     3) exec ccc ;;
    # esac
}





# _resolve3() {
#     TABLE="$(cat)"
#     while read -r module_path; do
#         if ! TABLE="$(echo "$TABLE" | $firechain_function "$module_path!module")"; then
#             error "resolve error: module error at $module_path" >&2
#             return 1
#         fi
#     done <<EOF
# $(echo "$module_paths" | tac)
# EOF
#     echo "$TABLE"
# }

# _simple_fire() {
#     target=$1
#     shift

#     if ! CONF_TABLE="$(
#             ENVE_PROFILE="$ENVE_PROFILE" \
#             ENVE_ROLES="${target},$ENVE_ROLES" \
#             ENVE_CONFIG="$ENVE_CONFIG" \
#             enve_parse_config
#             out_var core.target "$target")"; then
#         echo "fire error: parse_config error" >&2
#         return 1
#     fi
#     if ! module_paths="$(echo "$CONF_TABLE" | _simple_builtin_loader)"; then
#         echo "fire error: loader error" >&2
#         return 1
#     fi
#     if ! TABLE="$(echo "$CONF_TABLE" | module_paths="$module_paths" _resolve3)"; then
#         echo "fire error: resolve error" >&2
#         return 1
#     fi
#     if ! rccontent="$(UNAME_S=$(uname -s) execute_envdef "$TABLE" "$target")"; then
#         echo "fire error: make rcfile error" >&2
#         return 1
#     fi

#     RCFILE_PATH=$(mktemp)
#     echo "$rccontent" >> "$RCFILE_PATH"
#     chmod 755 "$RCFILE_PATH"
#     echo "rcfile: $RCFILE_PATH" >&2


#     bypass_setup=
#     case $target in
#         run)
#                 exec env - $bypass_setup bash "$RCFILE_PATH" "$@"
#             ;;
#         loader|module)
#                 exec bash "$RCFILE_PATH" "$@"
#             ;;
#         shell)
#             ;;
#         build)
#             ;;
#         install)
#             ;;
#         deploy)
#             ;;
#     esac
# }



true '
    fire_chain 改用 eval 機制
    eval.value
    eval.table
    eval.bound
    可以fire一個env行程來取得stdout的內容
    這中間可以通過注入的方法來更動內層次的設定依賴
    eval.value.$variable_name.fire = */enve.ini@target@role
    eval.value.$variable_name.config.$key = $value

    這個方法類似import機制
'


# get_module_info() {
#     : '
#     define.module                           模組定義
#     define.module.$i.$p.name     default is "$dirname"/*.enve.ini
#     define.module.$i.$p.procedure  must set
#     define.module.$i.$p.native_exec
#             default is false, no create enve
#     define.module.$i.$p.source_exec
#             default is false, not use fork, use "." instand
#     define.module.$i.$p.exec     default is %root/$procedure.enve.module
#     (X)define.module.$i.$p.order    must set
#     define.module.$i.$p.after    this may help ordering modules
#     define.module.$i.$p.before
#     '

#     : '

#     pasre `enve.ini` in module base folder to get module information.

#     @param module_root: base path of module
#     @print: [name,procedure,after,before,exec,options,enve path, ...]
#     '

#     module_root=$1
#     module_names=" "
#     TABLE=$(roles="module-info" parse_config_recursive "$module_root/enve.ini")
#     if [ -z "$TABLE" ]; then
#         return 1
#     fi
#     module_table=$(table_subset "define\\.module\\..*")
#     if [ -n "$module_table" ]; then
#         while IFS="$tab" read -r key value; do
#             # shellcheck disable=2034
#             IFS="." read -r __define __module name proce attrib <<EOF
# $key
# EOF
#             s=$name
#             replace "-" "_"
#             vname=$s
#             if [ "$attrib" = "after" ] || [ "$attrib" = "before" ]; then
#                 s=$value
#                 replace "," ":"
#                 s=${s##:}
#                 s=${s%%:}
#                 eval "MODULE_${vname}_${proce}_${attrib}=\"\${MODULE_${vname}_${proce}_${attrib}:-}\${s}:\""
#             else
#                 eval "MODULE_${vname}_${proce}_${attrib}=\$value"
#             fi
#             if [ -n "${module_names#*" $name/$proce "*}" ]; then
#                 module_names="$module_names$name/$proce "
#             fi
#         done <<EOF
# $module_table
# EOF
#     fi


#     for name_proce in $module_names; do
#         IFS='/' read -r name proce <<EOF
# $name_proce
# EOF
#         # name=${name_proce%%/*}
#         # proce=${name_proce##*/}
#         procedure=$proce

#         s=$name
#         replace "-" "_"
#         vname=$s

#         eval native_exec="\${MODULE_${vname}_${proce}_native_exec:-false}"
#         eval source_exec="\${MODULE_${vname}_${proce}_source_exec:-false}"
#         eval exec="\${MODULE_${vname}_${proce}_exec:-\$module_root/\$procedure.enve.module}"
#         eval enve="\${MODULE_${vname}_${proce}_enve:-./enve.ini}"
#         eval after="\":\${MODULE_${vname}_${proce}_after:-}\""
#         eval before="\":\${MODULE_${vname}_${proce}_before:-}\""

#         options=
#         if [ "$native_exec" = "true" ]; then
#             options="${options}native_exec=1;"
#         fi
#         if [ "$source_exec" = "true" ]; then
#             options="${options}source_exec=1;"
#         fi
#         exec=$(cd "$module_root"; canonicalize_symlinks "$exec")
#         enve=$(cd "$module_root"; canonicalize_symlinks "$enve")
#         # path=$(cd "$module_root"; canonicalize_symlinks "$module_root")
#         path=$(table_tail layout.root)
#         printf '%s,%s,%s,%s,%s,%s,%s,%s\n' \
#             "$name" "$procedure" "$after" "$before" "$exec" "$options" "$enve" "$path"
#     done
# }

_clock() {
    echo "[$(($(/nix/store/l687wir6a2iy3928hbv2n5y2nx1afkr8-boot-env/bin/date +%s%N) / 1000000))] $1" >&2
}

get_module_info() {
    : '
    define.module                           模組定義
    define.module.$i.$p.name     default is "$dirname"/*.enve.ini
    define.module.$i.$p.procedure  must set
    define.module.$i.$p.native_exec default is false, no create enve
    define.module.$i.$p.source_exec default is false, not use fork, use "." instand
    define.module.$i.$p.exec     default is %root/$procedure.enve.module
    (X)define.module.$i.$p.order    must set
    define.module.$i.$p.after    this may help ordering modules
    define.module.$i.$p.before
    '

    : '

    pasre `enve.ini` in module base folder to get module information.

    @param module_root: base path of module
    @print: [name,procedure,after,before,exec,options,enve,path, ...]
    '

    module_root=$1
    module_names=" "
    TABLE=$(roles="module-info" parse_config_recursive "$module_root/enve.ini")
    if [ -z "$TABLE" ]; then
        return 1
    fi

    fast_table_subset "define\\.module\\..*"
    while IFS="$tab" read -r key value; do
        if [ -z "$key" ]; then
            continue
        fi
        name=${key#*.*.}
        name=${name%.*.*}
        proce=${key#*.*.*.}
        proce=${proce%.*}
        attrib=${key#*.*.*.*.}

        s=$name
        replace "-" "_"
        vname=$s
        if [ "$attrib" = "after" ] || [ "$attrib" = "before" ]; then
            s=$value
            replace "," ":"
            s=${s##:}
            s=${s%%:}
            eval "MODULE_${vname}_${proce}_${attrib}=\"\${MODULE_${vname}_${proce}_${attrib}:-}\${value}:\""
        else
            eval "MODULE_${vname}_${proce}_${attrib}=\$value"
        fi
        # eval "MODULE_${vname}_${proce}_${attrib}=\$value"
        if [ -n "${module_names#*" $name/$proce "*}" ]; then
            module_names="$module_names$name/$proce "
        fi
    done <<EOF
$TABLE_SUBSET
EOF

    for name_proce in $module_names; do
        name=${name_proce%%/*}
        proce=${name_proce##*/}
        procedure=$proce

        s=$name
        replace "-" "_"
        vname=$s

        m_dict="MODULE_${vname}_${proce}"
        eval native_exec="\${${m_dict}_native_exec:-false}"
        eval source_exec="\${${m_dict}_source_exec:-false}"
        eval exec="\${${m_dict}_exec:-\$module_root/\$procedure.enve.module}"
        eval enve="\${${m_dict}_enve:-./enve.ini}"
        eval after="\":\${${m_dict}_after:-}\""
        eval before="\":\${${m_dict}_before:-}\""

        eval [ \"\${${m_dict}_native_exec+x}\" = x ] && unset ${m_dict}_native_exec
        eval [ \"\${${m_dict}_source_exec+x}\" = x ] && unset ${m_dict}_source_exec
        eval [ \"\${${m_dict}_exec+x}\" = x ] && unset ${m_dict}_exec
        eval [ \"\${${m_dict}_enve+x}\" = x ] && unset ${m_dict}_enve
        eval [ \"\${${m_dict}_after+x}\" = x ] && unset ${m_dict}_after
        eval [ \"\${${m_dict}_before+x}\" = x ] && unset ${m_dict}_before

        options=
        if [ "$native_exec" = "true" ]; then
            options="${options}native_exec=1;"
        fi
        if [ "$source_exec" = "true" ]; then
            options="${options}source_exec=1;"
        fi
        # exec=$(cd "$module_root"; canonicalize_symlinks "$exec")
        # enve=$(cd "$module_root"; canonicalize_symlinks "$enve")
        fast_table_tail "layout\\.root"
        path=$TABLE_TAIL
        exec="$path/${exec#./}"
        enve="$path/${enve#./}"
        # path=$(cd "$module_root"; canonicalize_symlinks "$module_root")
        # path=$(table_tail layout.root)
        # path=$module_root
        printf '%s,%s,%s,%s,%s,%s,%s,%s\n' \
            "$name" "$procedure" "$after" "$before" "$exec" "$options" "$enve" "$path"
    done
    unset m_native_exec m_source_exec m_exec m_enve m_after m_before
}


module_sort_after() {
    # arguments:
    #   modules
    #   name
    #   procefure
    #   afters
    #   befores
    # if [ -z "${name:-}" ]; then

    # shellcheck disable=2034
    IFS="," read -r name procedure afters befores remain<<EOF
$1
EOF
    # fi

    write_to=${2:-modules}
    # echo "MOD: $modules" >&2
    # echo "INST: $1" >&2
    min=
    max=
    e_index=0
    if [ -n "$modules" ]; then
        while IFS="," read -r e_name e_procedure e_afters e_befores e_remain; do
            if [ -z "${e_afters#*":$name:"*}" ] && [ "${max:-0}" -le "$e_index" ]; then
                max=$((e_index))
            fi
            if [ -z "${befores#*":$e_name:"*}" ] && [ "${max:-0}" -le "$e_index" ]; then
                max=$((e_index))
            fi
            if [ -z "${e_befores#*":$name:"*}" ] && [ "${min:-1000}" -ge "$e_index" ]; then
                min=$((e_index + 1))
            fi
            if [ -z "${afters#*":$e_name:"*}" ] && [ "${min:-1000}" -ge "$e_index" ]; then
                min=$((e_index + 1))
            fi
            e_index=$((e_index + 1))
        done <<EOF
$modules
EOF
    fi
    if [ -z "$min" ]; then
        min=0
    fi
    if [ -z "$max" ]; then
        max=$e_index
    fi
    if [ "$min" -gt "$max" ]; then
        _fatal "module ordering conflict, min: $min, max: $max"
        return 2
    else
        :
        # _debug "min: $min, max: $max | $name/$procedure($afters,$befores)"
    fi

    e_index=0
    head=
    tail=
    found_duplicated=
    found_last_bound=
    if [ -n "$modules" ]; then
        while IFS="," read -r e_name e_procedure e_afters e_befores e_remain; do
            if [ "$e_name" = "$name" ] && [ "$e_procedure" = "$procedure" ]; then
                found_duplicated=1
            fi
            if  [ -z "$found_last_bound" ] && [ $max -le $e_index ]; then
                found_last_bound=1
            fi
            if [ -z "$found_last_bound" ]; then
                head="${head:+$head$newl}$e_name,$e_procedure,$e_afters,$e_befores,$e_remain"
            else
                tail="${tail:+$tail$newl}$e_name,$e_procedure,$e_afters,$e_befores,$e_remain"
            fi
            e_index=$((e_index + 1))
        done <<EOF
$modules
EOF
    fi

    # echo "$min, $max" >&2
    # echo "head: $head" >&2
    # echo "tail: $tail" >&2
    if [ -n "$found_duplicated" ]; then
        eval "$write_to=\"\${head}\${tail:+\$newl\$tail}\""
    else
        eval "$write_to=\"\${head:+\$head\$newl}\$name,\$procedure,\$afters,\$befores,\$remain\${tail:+\$newl\$tail}\""
    fi
    if [ -n "${nonfast:-}" ]; then
        eval echo "\"\$$write_to\""
        # echo "$modules"
    fi
}



# exec_loaders() {
#     # loader 將會試圖從設定檔中解出更多外部模組
#     # 第一個執行的永遠是 $ENVE_HOME/evne/enve.loader
#     # 被讀進來的模組如果含有enve.loader, 則會加入loader的行列

#     next_loaders="${init_module_path}"
#     loader_execed=,
#     module_loaded="$newl"

#     while [ -n "$next_loaders" ]; do
#         loader_path="${next_loaders%%,*}"
#         next_loaders="${next_loaders#*,}"

#         # _trace "loader_path:   $loader_path"
#         # _trace "module_loaded: $module_loaded"
#         # _trace "next_loaders:  $next_loaders"

#         if [ -x "$loader_path/enve.loader" ]; then

#             if ! modules="$(echo "$TABLE" | ENVE_PROFILE="$loader_path/enve.ini" \
#                                             module_loaded="" \
#                                             ZERO="$loader_path" \
#                                             fire loader "$loader_path/enve.loader" "$0")"; then
#                 _error "loader execute failed"
#                 return 1
#             fi
#             loader_execed="${loader_execed}$loader_path,"
#             while read -r module; do
#                 module="$(canonicalize_symlinks "$module")"
#                 if [ "${module_loaded}" = "${module_loaded%$newl$module$newl}" ]; then
#                     if [ "$loader_execed" = "${loader_execed%,$module,}" ]; then
#                         next_loaders="${next_loaders}${module},"
#                     fi
#                     module_loaded="${module_loaded}${module}$newl"
#                     _debug "module '$module' found"
#                 else
#                     _debug "module '$module' already loaded"
#                 fi
#             done <<EOF
# $modules
# EOF
#         fi
#     done
#     unset loader_execed next_loaders loader_path module
#     module_loaded=${module_loaded##"$newl"}
#     module_loaded=${module_loaded%%"$newl"}
# }



# resolve() {
#     _trace "module_paths $module_paths"
#     [ -n "$module_paths" ] || {
#         _fatal "assert \$module_paths != ''"
#         return 1
#     }
#     while read -r module; do
#         if [ -x "$module/enve.module" ]; then
#             if ! TABLE="$(echo "$TABLE" | ENVE_PROFILE="$module/enve.ini" \
#                                           module_paths="" \
#                                           ZERO="$module" \
#                                           fire module "$module/enve.module" "$0")"; then
#                 _error "module execute error at $module"
#                 return 1
#             fi
#         fi
#     done <<EOF
# $module_paths
# EOF
# unset module
# }





exec_loaders_with_info() {
    # -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
    # loader 將會試圖從設定檔中解出更多外部模組
    # 第一個執行的永遠是 $ENVE_HOME/evne/enve.loader
    # 被讀進來的模組如果含有enve.loader, 則會加入loader的行列

    get_next_loader() {
        loader_enve=
        loader_exec=
        loader_options=
        loader_path=
        while IFS="," read -r   e_name e_procedure e_afters e_befores \
                                e_exec e_options e_enve e_path; do
            if [ "$loader_execed" = "${loader_execed%,$e_name,}" ]; then
                loader_enve=$e_enve
                loader_exec=$e_exec
                loader_options=$e_options
                loader_path=$e_path
                loader_execed="${loader_execed}$e_name,"
                break
            fi
        done <<EOF
$loader_infos
EOF
    }

    fire=${fire:-fire}
    # loader_infos="init,loader,${init_module_path},,,"
    module_loaded=
    loader_infos="$init_module_info"
    loader_execed=,

    get_next_loader
    while [ -n "$loader_exec" ]; do
        if [ -x "$loader_exec" ]; then
            if ! module_dirs="$(echo "$TABLE" | ENVE_PROFILE="$loader_enve" \
                                                module_loaded="" \
                                                ZERO="$loader_path" \
                                                MODULE_OPTION="$loader_options" \
                                                $fire loader "$loader_exec")"; then
                _error "loader execute failed"
                return 1
            fi
            if [ -n "$module_dirs" ]; then
                while read -r moddir; do
                    if mod_infos=$(get_module_info "$moddir"); then
                        while read -r modinfo; do
                            e_procedure=${modinfo#*,}
                            e_procedure=${e_procedure%%,*}
                            # echo "ISO: $isolation_modules" >&2
                            # LOGTYPE='load' _info "$e_name/$e_procedure"
                            if [ "$e_procedure" = "loader" ]; then
                                modules=$loader_infos module_sort_after "$modinfo" loader_infos
                            elif [ "$e_procedure" = "module" ]; then
                                modules=$module_loaded module_sort_after "$modinfo" module_loaded
                            elif [ "$e_procedure" = "post" ]; then
                                :
                            elif [ "$e_procedure" = "isolation" ]; then
                                modules="${isolation_modules:-}" module_sort_after "$modinfo" isolation_modules

                            else
                                :
                            fi
                        done <<EOF
$mod_infos
EOF
                    else
                        _warning "get_module_info error on $moddir"
                    fi
                done <<EOF
$module_dirs
EOF
            fi
        fi
        get_next_loader
    done
    # unset loader_execed next_loaders loader_path module
    # module_loaded=${module_loaded##"$newl"}
    # module_loaded=${module_loaded%%"$newl"}
}



resolve_with_info() {
    # -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

    fire=${fire:-fire}
    # _trace "module_paths $module_paths"
    [ -n "$module_paths" ] || {
        _fatal "assert \$module_paths != ''"
        return 1
    }
    while IFS="," read -r   e_name e_procedure e_afters e_befores \
                            e_exec e_options e_enve e_path; do
        LOGTYPE='module' _info "$e_name/$e_procedure: $e_exec"
        if [ -x "$e_exec" ]; then
            if ! TABLE="$(  echo "$TABLE" | ENVE_PROFILE="$e_enve" \
                                            module_paths="" \
                                            ZERO="$e_path" \
                                            MODULE_OPTION="$e_options" \
                                            MODULE_NAME="$e_name" \
                                            $fire module "$e_exec")"; then
                _error "module execute error at $e_name"
                return 1
            fi

        fi
        out_var_just module.loaded "$e_name"
    done <<EOF
$module_paths
EOF
unset   e_name e_procedure e_afters e_befores \
        e_exec e_options e_enve e_path
}


# EXTRA_CENVE_PROFILE: user specficed config files, use as import at beginning

get_rcfile_from_profiles_nocache() {
    # input:
    #   ENVE_PROFILE
    #   ENVE_ROLES
    #   ENVE_CONFIG
    #   RCFILE_PATH
    # output:
    #   boundfiles
    # sideeffect:
    #   write $RCFILE_PATH

    # proc            cond    hash                    vaild       make
    # --------------------------------------------------------------------
    # final-rc        -       url|profile             rc+marks    genrcfile
    #   checkout      url     url|profile             -           fetch
    #   paser&load    -       -
    #   settle        m       sub(s, pTABLE)          rootmark    settle
    #   install       m       sub(i, pTABLE)+artifact installmark unpack
    #     build       m       sub(b, pTABLE)+source   artifact    exec build
    #       build-rc  m       sub(b, pTABLE)          rc          genrcfile
    #   setup         m       sub(u, pTABLE)          setupmark   setup

    [ -n "${UNAME_S_MEMO:-}" ] || UNAME_S_MEMO=$(uname -s)

    if [ "$ENVE_PROFILE" = "$ENVE_HOME/enve/enve.ini" ]; then
        TABLE=
        out_var_just core.target $target
        out_var_just sh_module 1
    else
        # TODO(untested): checkout procedure
        # TODO: isurl

        # OLDIFS=$IFS; IFS=,
        # if [ -z "${ENVE_MAIN_PROFILE:-}" ]; then
        #     for cfile in $ENVE_PROFILE; do
        #         ENVE_MAIN_PROFILE=$cfile
        #     done
        # fi
        # IFS=$OLDIFS
        # if is_url "$ENVE_MAIN_PROFILE"; then
        #     ENVE_PROFILE=",$ENVE_PROFILE"
        #     ENVE_PROFILE="${ENVE_PROFILE#*,$ENVE_MAIN_PROFILE,}${ENVE_PROFILE%%,$ENVE_MAIN_PROFILE,*}"
        #     ENVE_PROFILE=${ENVE_PROFILE#,}
        #     ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$(fetch "$ENVE_MAIN_PROFILE")/enve.ini"
        # fi

        origin_ENVE_PROFILE=$ENVE_PROFILE
        wait_ENVE_PROFILE=$ENVE_PROFILE
        ENVE_PROFILE=
        OLDIFS=$IFS; IFS=,
        for cfile in $wait_ENVE_PROFILE; do
            parse_unified_download "$cfile" "%cache" "auto" "noerror" || true
            if [ "${dl#cp}" != "$dl" ] || [ "$dl" = "relative" ]; then
                # cfile is a local path
                if [ -d "$cfile" ]; then
                    ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$cfile/enve.ini"
                else
                    ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$cfile"
                fi
            else
                # cfile is a remote url
                cfile="$(settrace; fetch "$cfile" "%cache" "auto")/enve.ini"
                ENVE_PROFILE="${ENVE_PROFILE}${ENVE_PROFILE:+,}$cfile"
            fi
        done
        IFS=$OLDIFS

        echo "ENVE_PROFILE:$ENVE_PROFILE" >&2

        # parse procedure
        TABLE="$(
                    settrace
                    ENVE_PROFILE="$ENVE_PROFILE" \
                    ENVE_ROLES="$ENVE_ROLES" \
                    ENVE_CONFIG="$ENVE_CONFIG" \
                    enve_parse_config
                    out_var_fast core.target $target)" || {
            _error "parse_config failed"
            return 1
        }
        # _trace "=============$newl$TABLE"
        LOGLEVEL=DEBUG log "=== parse ???-$target ==="
        LOGLEVEL=DEBUG logtable "$TABLE"

        if [ -n "$origin_ENVE_PROFILE" ] && [ -z "$(table_subset "enve\\.configs")" ]; then
            _error "none of config file is parsed, cannot continue"
            return 1
        elif [ -z "$origin_ENVE_PROFILE" ]; then
            out_var_just enve.nobound true
        fi

        # load procedure

        # TABLE="$TABLE" init_module_path="$ENVE_HOME/enve," exec_loaders || {
        #     _error "exec_loaders failed"
        #     return 1
        # }

        # TODO: loader2.0
        # while IFS="," read -r e_name e_procedure e_afters e_befores \
        #                       e_exec e_options e_enve e_path; do
        TABLE="$TABLE" \
        init_module_info="base,loader,:,:,$ENVE_HOME/enve/core/base/enve.loader,source_exec=1;native_exec=1;,,$ENVE_HOME/enve/core/base" \
        exec_loaders_with_info || {
            _error "exec_loaders failed"
            return 1
        }
    fi



    if [ -n "${isolation_modules:-}" ]; then
        while IFS="," read -r e_name e_procedure e_remain; do
            LOGTYPE='iso' _info "$e_name/$e_procedure"
            last_isolation_name=$e_name
        done <<EOF
$isolation_modules
EOF
        while IFS="," read -r   e_name e_procedure e_afters e_befores \
                                e_exec e_options e_enve e_path; do
            if [ "$e_name" = "$last_isolation_name" ]; then
                out_var_just "isolation.exec" "$e_exec" META
                out_var_just "isolation.options" "$e_options" META
                out_var_just "isolation.enve" "$e_enve" META
            fi
        done <<EOF
$isolation_modules
EOF
    fi


    # TODO: resolve?? procedure
    # _trace "module_paths_loaded --> ${module_loaded:+$newl}${module_loaded:-}"
    if [ -n "$module_loaded" ]; then
#         while read -r mpath; do
#             out_var_just module.loaded "$mpath"
#         done <<EOF
# $module_loaded
# EOF
#         module_paths="${module_loaded:-}" module_loaded="" resolve || {
#             _error "resolve failed"
#             return 1
#         }

        # shellcheck disable=2034
#         while IFS="," read -r e_name e_procedure _e_afters _e_befores e_exec _e_remain; do
#             LOGTYPE='module' _info "$e_name/$e_procedure: $e_exec"
#             out_var_just module.loaded "$e_name"
#         done <<EOF
# $module_loaded
# EOF
        # shellcheck disable=2097,2098
        module_paths="${module_loaded:-}" module_loaded="" resolve_with_info || {
            _error "resolve failed"
            return 1
        }
    fi

    # add extra enve bound files
    while read -r envebound; do
        if [ -n "$envebound" ]; then
            out_var_just bound "$ENVE_HOME/$envebound"
        fi
    done <<EOF
$(cd "$ENVE_HOME"; find enve ! -type d ! -name .DS_Store)
EOF
    LOGLEVEL=DEBUG log "=== resolve ???-$target ==="
    LOGLEVEL=DEBUG logtable "$TABLE"

    # filter table finally
    PAST_TABLE=$TABLE
    TABLE=
    boundfiles=
    OLDIFS=$IFS
    IFS=$tab
    while read -r ctype key value; do
        case "$ctype$tab$key" in
            VAR"${tab}"bound)
                    boundfiles="${boundfiles}${boundfiles:+$newl}$value"
                ;;
            VAR"${tab}"*'.'*|"$tab"|VAR"${tab}shell"|VAR"${tab}module")
                    :
                ;;
            *)
                    out_var_just "$key" "$value" "$ctype"
                ;;
        esac
    done <<EOF
$PAST_TABLE
EOF
    IFS=$OLDIFS

    # generate final rcfile
    UNAME_S=$UNAME_S_MEMO \
    PAST_TABLE="$PAST_TABLE" \
    execute_envdef "$TABLE" "$target" > "$RCFILE_PATH" || {
        _error "execute_envdef failed"
        return 1
    }

    _debug "RC DONE"
    chmod 755 "$RCFILE_PATH"
    echo "$boundfiles"
}



get_rcfile_from_profiles_usecache() {
    # input:
    #   ENVE_PROFILE
    #   ENVE_ROLES
    #   ENVE_CONFIG
    # output:
    #   rcfile path

    mkrcfile() {
        boundfiles="$(
                settrace
                ENVE_PROFILE="$ENVE_PROFILE" \
                ENVE_ROLES="$ENVE_ROLES" \
                ENVE_CONFIG="$ENVE_CONFIG" \
                RCFILE_PATH="$1" \
                get_rcfile_from_profiles_nocache)" || return 1
    }

    if [ "${ENVE_CACHE_DIR:-}" != "nocache" ]; then
        p_text() {
            printf %s\\n "v20190308v1"
            printf %s\\n "$ENVE_ROLES"
            printf %s\\n "$ENVE_CONFIG"
            printf %s\\n "$ENVE_PROFILE"
            IFS=','
            for file in $ENVE_PROFILE; do
                if [ -e "$file" ]; then
                    fast_readtext "$file"
                    printf %s\\n "$text"
                fi
            done
        }

        p_vaild() {
            fast_readtext "$CACHED/boundfiles" || {
                _trace F1
                return 0
            }
            boundfiles="$text"
            boundhashes=$(files_stats $boundfiles) || {
                _trace F2
                return 0
            }
            fast_readtext "$CACHED/hashes" || {
                _trace F3
                return 0
            }
            excepted_boundhashes="$text"
            [ "$boundhashes" = "$excepted_boundhashes" ] || {
                _trace F4
                return 0
            }
            [ -s "$CACHED/rcfile" ] || {
                _trace F5
                return 0
            }
            echo 1
        }
        p_make() {
            mkrcfile "$CACHED/rcfile"
            # boundhashes="$(files_stats_contents $boundfiles | hashstr)"
            boundhashes=$(files_stats $boundfiles)
            _trace "profile: $ENVE_PROFILE"
            _trace "write to: $CACHED/boundfiles"
            echo "$boundfiles" > "$CACHED/boundfiles"
            echo "$boundhashes" > "$CACHED/hashes"
        }
        d=$(settrace
            catalog=boundfile cache_path "." p_text p_make p_vaild
            echo "$cached_path")
        fast_dirname
        RCFILE_PATH="$d/rcfile"
        BOUNDFILE_PATH="$d/boundfiles"
    else
        if ! tmprcfile="$(mkstemp ${TMPDIR:-/tmp}/rcfile.XXXXXX)"; then
            _error "failed to create tempfile"
            return 1
        fi
        mkrcfile "$tmprcfile"
        RCFILE_PATH=$tmprcfile
        BOUNDFILE_PATH=
    fi

    # echo "$RCFILE_PATH"
}


# errfunc() {
#     echo "x" >&2
#     false
# }

fire() {
    target=$1
    shift
    ENVE_ROLES="${target},${ENVE_ROLES}"
    ENVE_FIRE_DEPTH="$((${ENVE_FIRE_DEPTH:--1} + 1))"

    # for ENVE_CACHED_OS
    fast_get_system
    export ENVE_CACHED_OS

    LOGTYPE=fire _info "level $ENVE_CACHED_OS $ENVE_FIRE_DEPTH $target $*"

    ensure_readlink_command
    if [ -z "${ENVE_CACHE_DIR:-}" ]; then
        ENVE_CACHE_DIR=$(get_cachedir)
    fi
    export ENVE_CACHE_DIR
    export ENVE_READLINK

    MODULE_OPTION="${MODULE_OPTION:-};"
    if [ -z "${MODULE_OPTION%%*source_exec=1;*}" ]; then
        sh_module=1
    fi
    if [ -z "${MODULE_OPTION%%*native_exec=1;*}" ]; then
        # direct execute without rcfile
        RCFILE_PATH=$1
        shift
    else
        # get_rcfile_from_profiles
        get_rcfile_from_profiles_usecache
        if [ -z "$RCFILE_PATH" ]; then
            return 1
        fi

        while read -r line; do
            case $line in
                *"; export SHELL")
                        cuts=${line%\'; export SHELL}
                        invoke_shell=${cuts#*SHELL=\'}
                    ;;
                *"; export PRJ_NAME")
                        cuts=${line%\'; export PRJ_NAME}
                        PRJ_NAME=${cuts#*PRJ_NAME=\'}
                    ;;
                # *"; export INVOKE_SHELL")
                #         cuts=${line%\'; export INVOKE_SHELL}
                #         invoke_shell=${cuts#*INVOKE_SHELL=\'}
                #     ;;
                *"; export ENVE_TERMINAL")
                        cuts=${line%\'; export ENVE_TERMINAL}
                        invoke_termainal=${cuts#*ENVE_TERMINAL=\'}
                    ;;
                *"; export BYPASS")
                        cuts=${line%\'; export BYPASS}
                        invoke_bypass=${cuts#*BYPASS=\'}
                    ;;
                # *"; export sh_module")
                #         cuts=${line%\'; export sh_module}
                #         sh_module=${cuts#*sh_module=\'}
                #     ;;
                \#"META: VAR$tab"*)
                        cuts=${line#\#"META: VAR$tab"}
                        IFS=$tab read -r key value <<EOF
$cuts
EOF
                        case $key in
                            isolation.exec)
                                    isoexec=$value
                                ;;
                            isolation.options)
                                    # TODO:
                                    # shellcheck disable=2034
                                    isooptions=$value
                                ;;
                            # isolation.enve)
                            #         isoenve=$value
                            #     ;;
                        esac
                    ;;
            esac
            # if [ "${line%; export SHELL}" != "$line" ]; then
            #     cuts=${line%\'; export SHELL}
            #     invoke_shell=${cuts#*SHELL=\'}
            # elif [ "${line%; export BYPASS}" != "$line" ]; then
            #     cuts=${line%\'; export BYPASS}
            #     invoke_bypass=${cuts#*BYPASS=\'}
            # fi
        done < "$RCFILE_PATH"
    fi

    deftext="ENVE_FIRE_DEPTH='$ENVE_FIRE_DEPTH'"
    if [ -n "${invoke_bypass:-}" ]; then
        OLDIFS=$IFS; IFS=':'
        for var in $invoke_bypass; do
            fast_append_variable_quote "$var"
        done
        IFS=$OLDIFS
    fi
    bypass_envs=$deftext

    # _debug "bypass_envs: $bypass_envs"
    invoke_shell=${invoke_shell:-$SHELL}
    _notice "enter $RCFILE_PATH by $invoke_shell"

    # this is for $ENVE_PROGRESS
    # if [ "${ENVE_FIRE_DEPTH}" -eq 0 ]; then
    #     echo "" >&2
    # fi

    exec_isoexec() {
        if [ -z "${isoexec:-}" ]; then
            _fatal "no isolation is specficed"
        fi

        d=$isoexec
        fast_dirname
        ZERO=$d
        unset d

        ZERO=$ZERO \
        PRJ_NAME=$PRJ_NAME \
        target=$target \
        invoke_shell=$invoke_shell \
        invoke_termainal="${invoke_termainal:-}" \
        bypass_envs=$bypass_envs \
        ENVE_HOME=$ENVE_HOME \
        RCFILE_PATH=$RCFILE_PATH \
        exec "$isoexec" "$@"
    }

    case $target in
        shell|run|terminal)
                exec_isoexec
            ;;
        test)
                bypass_envs="$bypass_envs ENVE_HOME='$ENVE_HOME'"
                target=run exec_isoexec
            ;;
        build|setup)
                bypass_envs="${bypass_envs:+$bypass_envs }PRJ_OUT='xxxTODO'"
                target=run exec_isoexec
            ;;
        loader|module)
                if [ -n "${sh_module:-}" ]; then
                    # shellcheck disable=1090
                    . "$RCFILE_PATH"
                    # shellcheck disable=1090
                    main "$@"
                else
                    exec_isoexec "$@"
                fi
                if [ "$target" = "module" ] && [ -f "${BOUNDFILE_PATH:-}" ]; then
                    while read -r bound; do
                        out_var_fast bound "$bound"
                    done < "$BOUNDFILE_PATH"
                fi
            ;;
        execute)
            ;;
    esac
}

enve_fire() {
    fire "$@"
}



