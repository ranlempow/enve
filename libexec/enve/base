#!/usr/bin/env bash

if [ -n "${HAVE_ENVE_BASE:-}" ]; then
    return 0
fi
HAVE_ENVE_BASE=1


ENVE_PROGRAM_NAME="${0##*/}"


tab="$(printf '\tx')"
tab="${tab%x}"
newl="$(printf '\nx')"
newl="${newl%x}"

hascmd() {
    command -v "$1" >/dev/null
}


if ! hascmd md5sum; then
    # BSD
    md5sum() {
        md5 -r "$@"
    }
fi
if ! hascmd tac; then
    # BSD
    tac() {
        tail -r
    }
fi


in_busybox_shell() {
    [ "$SHELL" = "/bin/ash" ] && [ "$(ps -o pid,comm | awk '$1=='"$$"'{ print $2 }' | tail -n 1)" = "busybox" ]
}

if in_busybox_shell; then
    # busybox shell
    :
fi

fast_get_system() {
    if [ -z "${ENVE_CACHED_OS:-}" ]; then
        case $(uname -s) in
            Linux*)     ENVE_CACHED_OS=Linux;;
            FreeBSD*)   ENVE_CACHED_OS=FreeBSD;;
            OpenBSD*)   ENVE_CACHED_OS=OpenBSD;;
            Darwin*)    ENVE_CACHED_OS=Darwin;;
            CYGWIN*)    ENVE_CACHED_OS=CYGWIN;;
            MSYS*)      ENVE_CACHED_OS=MSYS;;
            MINGW32*)   ENVE_CACHED_OS=MINGW32;;
            MINGW64*)   ENVE_CACHED_OS=MINGW64;;
            *)          ENVE_CACHED_OS=Unknown;;
        esac
        export ENVE_CACHED_OS
    fi
}

replace() {
    if [ -z "$1" ]; then
        return 0
    fi

    count=${3:-}
    i=0
    v=
    while [ "$s" != "${s%%"$1"*}" ]; do
        v="$v${s%%"$1"*}$2"
        s="${s#*"$1"}"
        i=$((i+1))
        if [ -n "$count" ] && [ "$count" -eq "$i" ]; then
            break
        fi
    done
    s="$v$s"
    unset count i v
}


hashstr() {
    # data="$(cat)"
    # echo "$data" | md5sum "$@" | while read -r sha __file; do
    # shellcheck disable=2034
    # md5sum "$@" | while read -r hashvalue __file; do

    result=$(md5sum "$@")
    hashvalue=
    while read -r _hashvalue __file; do
        hashvalue=${_hashvalue}
        echo "$hashvalue"
        unset _hashvalue __file
    done <<EOF
$result
EOF

}


# _verify_ssh_live() {
#     IFS=':' read -r method hash keyexp path sshtype pub < $mainkey_live_path
#     if [ ! -e "$path" ]; then
#         _need_ssh_add=1
#         return
#     fi
#     IFS=' ' read -r curr_sshtype curr_pub curr_comment < "$path"
#     if [ "$curr_sshtype" != "$sshtype" ] ||
#        [ "$curr_pub" != "$pub" ]; then
#         _need_ssh_add=1
#         return
#     fi
#     fast_timestamp_ms
#     if [ "$ts" -gt "$keyexp" ]; then
#         _need_ssh_add=1
#         return
#     fi
#     _need_ssh_add=
# }


# ensure_main_sshkey() {
#     timeout=$((60*60*6))
#     _need_ssh_add=
#     # if [ -z "${ENVE_MAIN_KEY:-}" ] || [ ! -e "$ENVE_MAIN_KEY" ]; then
#     #     _need_ssh_add=1
#     # else
#     #     IFS=':' read -r method hash keyexp < $ENVE_MAIN_KEY
#     #     fast_timestamp_ms
#     #     if [ "$ts" -gt "$keyexp" ]; then
#     #         _need_ssh_add=1
#     #     fi
#     # fi
#     if [ ! -e "/tmp/key_live" ]; then
#         mkdir -p /tmp/key_live
#     fi
#     mainkey_live_path="/tmp/key_live/$USER"
#     if [ ! -e "$mainkey_live_path" ]; then
#         _need_ssh_add=1
#     else
#         _verify_ssh_live
#     fi

#     if [ -n "$_need_ssh_add" ]; then
#         if [ -e "${ENVE_USERHOME}/.ssh/id_ed25519" ]; then
#             ssh-add "${ENVE_USERHOME}/.ssh/id_ed25519" -t "$timeout"
#         elif [ -e "${ENVE_USERHOME}/.ssh/id_rsa" ]; then
#             ssh-add "${ENVE_USERHOME}/.ssh/id_rsa" -t "$timeout"
#         else
#             _error "there is no key in '${ENVE_USERHOME}/.ssh'"
#             return 1
#         fi
#         while read -r bit sig path keytype; do
#             if [ "$path" = ${ENVE_USERHOME}/.ssh/id_ed25519 ] ||
#                [ "$path" = ${ENVE_USERHOME}/.ssh/id_rsa ]; then

#                 IFS=':' read method hash <<EOF
# $sig
# EOF
#                 IFS=' ' read -r sshtype pub comment < "$path"
#                 fast_timestamp_ms
#                 echo "$sig:$((tm + timeout)):$path:$sshtype:$pub" > $mainkey_live_path
#                 break
#             fi
#         done <<EOF
# $(ssh-add -l)
# EOF
#     fi
#     unset timeout _need_ssh_add mainkey_live_path tm s method hash keyexp bit sig path keytype
# }


timestamp() {
    # date +%s%N | cut -b5-13
    tm=$(date +%s%N)
    # tm=$(/nix/store/p0zfmny1vsb4ryzn67p4rbm0nqk78yya-boot-env/bin/date +%s%N)
    tm=${tm#?????}
    tm=${tm%${tm#????????}}
    echo "$tm"
    unset tm
}

timestamp2() {
    tm=$(date +%s%N)
    # tm=$(/nix/store/p0zfmny1vsb4ryzn67p4rbm0nqk78yya-boot-env/bin/date +%s%N)
    tm=${tm#?????}
    tm=${tm%${tm#????????}}
    echo "$tm"
    unset tm
}

timestamp_ms() {
    tm=$(date +%s%3N)
    if [ "${tm#"${tm%??}"}" == "3N" ]; then
        tm=$(( ${tm%??} * 1000))
    fi
}
fast_timestamp_ms() {
    if [ -n "${BASH_VERSION}" ]; then
        printf -v tm '%(%s%3N)T' -1
    else
        tm=$(date +%s%3N)
    fi
    if [ "${tm#"${tm%??}"}" == "3N" ]; then
        tm=$(( ${tm%??} * 1000))
    fi
}


fast_sleep() {
    # ref: https://unix.stackexchange.com/questions/421189/sometimes-its-convenient-to-use-read-t-3-instead-of-sleep-3-how-do-i/421201#421201
    # read -t 3 (a ksh93 extension now also supported by zsh, bash and mksh)
    if [ -n "${BASH_VERSION:-}${ZSH_VERSION:-}${KSH_VERSION:-}" ]; then
        pipepath="${TMPDIR:-/tmp}/sleep.pipe"
        rm -f "$pipepath"
        if [ ! -e "$pipepath" ]; then
            mkfifo -m 600 "$pipepath" || true
        fi
        read -t "$1" <> "$pipepath" || true
    else
        sleep "$1"
    fi
}


write_file_only_nonexist() {
    filename=$1
    text=${2:-}
    mask=${3:-0022}
    _need_noclobber=
    # _old_mask=$(umask)
    umask $mask
    if [ "${-#*C}" = "$-" ]; then
        # need set `noclobber`
        _need_noclobber=1
    fi
    if [ -n "$_need_noclobber" ]; then set -o noclobber; fi
    # if { echo "$text" > $filename; } 2>/dev/null; then
    if { printf %s "$text" > $filename; } 2>/dev/null; then
        set -- 0
    else
        set -- 1
    fi
    if [ -n "$_need_noclobber" ]; then set +o noclobber; fi
    # umask ${_old_mask}
    umask 0022
    unset _need_noclobber filename text mask
    return $1
}

fast_append_variable_quote() {
    var=$1
    if [ -n "$var" ] && [ "${var#*'$'}" = "${var}" ]; then
        eval s=\"\${$var-var_is_unset}\"
        if [ "$s" != var_is_unset ]; then
            replace "'" "'\\''"
            printf -v deftext "%s%s='%s'" "$deftext${deftext:+ }" "$var" "$s"
        fi
    fi
    unset var s
}

fast_readtext() {
    text=
    while IFS='' read -r line; do
        text="$text${text:+$newl}$line"
    done < "$1"
    unset line
}

fast_dirname() {
    d=${d%%/}
    if [ -z "$d" ]; then
        d=\.
    elif [ -z "${d%/*}" ]; then
        d=/
    elif [ "$d" = "${d%/*}" ]; then
        d=\.
    else
        d=${d%/*}
    fi
}

fast_basename() {
    if [ -n "$d" ]; then
        d=${d%%/}
        if [ -n "$d" ]; then
            d=${d##*/}
        else
            d=/
        fi
    fi
}


# combine_umask() {
#     mask=
#     eval "mask=$((0$(umask) & 0$1))"
#     printf %o\\n "$mask"
# }

create_file_mutex() {
    write_file_only_nonexist "$1" "" "${2-077}"
    # (
    #     umask "$(combine_umask "${2:-7077}")"
    #     set -o noclobber
    #     { true > "$1" ; } >/dev/null 2>&1
    # )
}

create_dir_mutex() {
    filename=$1
    mask=${2:-077}
    umask $mask
    # _old_mask=$(umask)
    if { mkdir "$filename" ; } 2>/dev/null; then
        set -- 0
    else
        set -- 1
    fi
    umask 0022
    # umask ${_old_mask}
    unset _old_mask filename
    return $1
    # (
    #     umask "$(combine_umask "${2:-7077}")"
    #     mkdir "$1" >/dev/null 2>&1
    # )
}

_sixrand50() {
    # shellcheck disable=1004
    awk 'BEGIN {  srand(); for (i = 1; i <= 50; i++)
                        printf("%c%c%c%c%c%c\n" , rand() * 26 + 97, rand() * 26 + 97 \
                                                , rand() * 26 + 97, rand() * 26 + 97 \
                                                , rand() * 26 + 97, rand() * 26 + 97) }'
}

_rand=$(_sixrand50)
ENVE_SESSION_ID=${_rand%%"$newl"*}

_mkstemp() {
    mutex_function=$1
    shift

    rands="$(_sixrand50)"
    prefix="${1%XXXXXX}"
    if [ "$prefix" = "$1" ]; then
        return 1
    fi
    shift

    for rand in $rands; do
        if $mutex_function "$prefix$rand" "$@"; then
            echo "$prefix$rand"
            return 0
        fi
    done
    return 1
}

mkstemp() {
    _mkstemp create_file_mutex "$@"
}
mkdtemp() {
    _mkstemp create_dir_mutex "$@"
}



# enve is a stateless program, that is unnecessary to use '/var'

fast_get_cachedir() {
    if [ -n "${ENVE_CACHE_DIR:-}" ]; then
        d="$ENVE_CACHE_DIR"
        return 0
    else
        d=$(get_cachedir)
    fi
}

get_cachedir() {
    if [ -n "${ENVE_CACHE_DIR:-}" ]; then
        echo "$ENVE_CACHE_DIR"
        return 0
    fi
    # kernal_name="$(uname -s)"
    # case "$kernal_name" in
    fast_get_system
    case "$ENVE_CACHED_OS" in
        Linux|FreeBSD|Darwin)
                # macos $HOME do not have issus as in windows
                # $HOME always contain only alphanum without space and all lowercase.

                # echo ~/Library/Caches/enve

                # shellcheck disable=2034
                read -r fileperm x2 fileuser x4 x5 x6 x7 x8 path <<EOF
$(ls -ld /var/cache/enve 2>/dev/null)
EOF
                if [ "$fileperm" = "drwxrwxrwt" ] && [ "$fileuser" = "root" ]; then
                    echo /var/cache/enve
                else
                    echo ~/.cache/enve
                fi

            ;;
        # Linux|FreeBSD)
        #         if [ "$(id -u)" -eq 0 ]; then
        #             echo /var/cache/enve
        #         else
        #             echo ~/.cache/enve
        #         fi
        #     ;;
        MINGW*|MSYS*|CYGWIN*)
                # $LOCALAPPDATA is the temporary files of Applications.
                # but $HOME may contain non-acsii character or space.
                # so, we use $ProgramData
                # The file system directory that contains application data for all users.

                # shellcheck disable=2154
                cygpath -u "$ProgramData/enve"
            ;;
        *)
                echo /var/cache/enve
            ;;
    esac
}

fast_get_tempdir() {
    if [ -n "${TMP:-}" ]; then
        d="${TMP%%/}"
    elif [ -n "${TMPDIR:-}" ]; then
        d="${TMPDIR%%/}"
    elif [ -n "${TEMP:-}" ]; then
        d="${TEMP%%/}"
    elif [ -n "${TEMPDIR:-}" ]; then
        d="${TEMPDIR%%/}"
    else
        d="/tmp"
    fi
}

get_tempdir() {
    fast_get_tempdir
    echo "$d"
    unset d
    # if [ -n "${TMP:-}" ]; then
    #     echo "${TMP%%/}"
    # elif [ -n "${TMPDIR:-}" ]; then
    #     echo "${TMPDIR%%/}"
    # elif [ -n "${TEMP:-}" ]; then
    #     echo "${TEMP%%/}"
    # elif [ -n "${TEMPDIR:-}" ]; then
    #     echo "${TEMPDIR%%/}"
    # else
    #     echo "/tmp"
    # fi
}

# quote () { printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/" ; }
# save () {
#     for i do quote "$i"; done
#     echo " "
# }


any_key_continue() {
    if [ -n "${PS1:-}" ]; then
        echo "Press enter to continue"
        # shellcheck disable=2034
        read -r X
        unset X
    fi
}


# syslog: emerg, alert, crit, err, warning, notice, info, debug
# python: CRITICAL ERROR WARNING INFO DEBUG


_loglevel_form_symbol() {
    case ${ENVE_VERBOSE:-TRACE} in
        CRIT|CRITICAL)  loglevel=6 ;;
        ERROR)          loglevel=5 ;;
        WARN|WARNING)   loglevel=4 ;;
        NOTICE)         loglevel=3 ;;
        INFO)           loglevel=2 ;;
        DEBUG)          loglevel=1 ;;
        TRACE)          loglevel=0 ;;

        *)              loglevel=3 ;;
    esac
    if [ "${1:-nonfast}" = "nonfast" ]; then
        echo "$loglevel"
    fi
}

obtain_pidlock() {
    trycnt=1
    filename=$1
    while ! write_file_only_nonexist "$filename" "$$"; do
        read -r pid < "$filename" || true
        if [ -n "$pid" ]; then
            if [ "$pid" = "$$" ]; then
                return 0
            elif kill -0 "$pid"; then
                rm -f "$filename" || return 1
            else
                return 1
            fi
        else
            rm -f "$filename" || return 1
        fi
        trycnt=$((trycnt + 1))
        if [ "$trycnt" -gt 20 ]; then
            return 1
        fi
    done
    unset trycnt filename
}


release_pidlock() {
    read -r pid < "$filename" || return 1
    if [ "$pid" = "$$" ]; then
        rm "$filename"
    elif kill -0 "$pid"; then
        rm -f "$filename"
        return 1
    else
        return 1
    fi
}


obtain_filelock() {
    filename=$1
    timeout=$2
    if { read pid ts to < $filename; } 2>/dev/null; then
        fast_timestamp_ms
        if [ "$ts" -gt $to ]; then
            # filelock is expire
            rm "$filename"
        elif [ "$pid" == "$$" ]; then
            # same pid filelock cloud refresh
            rm "$filename"
        else
            return 1
        fi
    fi
    set -- $filename
    unset filename pid ts to
    fast_timestamp_ms
    write_file_only_nonexist "$1" "$$ $tm $((tm + timeout))" "7077"
    # _need_noclobber=
    # if [ "${-#*C}" = "$-" ]; then
    #     # need set `noclobber`
    #     _need_noclobber=1
    # fi
    # if [ -n "$_need_noclobber" ]; then set -o noclobber; fi
    # if { echo "$$ $tm $((tm + timeout))" > $filename; } 2>/dev/null; then
    #     return 0
    # else
    #     return 1
    # fi
    # if [ -n "$_need_noclobber" ]; then set +o noclobber; fi
}


release_filelock() {
    filename=$1
    if { read pid ts to < $filename; } 2>/dev/null; then
        if [ "$pid" == "$$" ]; then
            rm "$filename"
            unset filename pid ts to
            return 0
        fi
    fi
    unset filename pid ts to
    # file is removed or obtained by other process
    return 1
}




_format_head() {
    fmts=
    ptime=
    print_fire_depth=

    if [ -n "${ENVE_TIME_PROFILE:-}" ]; then
        case ${ENVE_VERBOSE:-TRACE} in
            DEBUG)  ptime=$(date -u +"%D %T");;
            TRACE)
                    timestamp_ms
                    ptime=$tm
                    unset tm
                ;;
        esac
    fi
    if [ -t 2 ] && [ -z "${ENVE_NOCOLOR:-}" ]; then
        C0='\033[0m'
        C1='\033[36m'
        C2='\033[35m'
        Cr='\033[31m'
        case $1 in
            critical|error) C2="$Cr" ;;
        esac

        case ${ENVE_VERBOSE:-TRACE} in
            CRIT|CRITICAL)  fmts="$C1%4s$C0 $C2%8s$C0" ;;
            ERROR)          fmts="$C1%4s$C0 $C2%8s$C0" ;;
            WARN|WARNING)   fmts="$C1%4s$C0 $C2%8s$C0" ;;
            NOTICE)         fmts="$C1%4s$C0 $C2%8s$C0" ;;
            INFO)           fmts="$C1%4s$C0 $C2%8s$C0" ;;
            DEBUG)          fmts="${ptime:+"[$ptime]" }$C1%4s$C0 %1s $C2%8s$C0"
                            print_fire_depth=true
                ;;
            TRACE)          fmts="${ptime:+"[$ptime]" }$C1%4s$C0 %1s $C2%8s$C0"
                            print_fire_depth=true
                ;;
            # DEBUG)          eval "fmts=\"[$(date -u +"%D %T")] $C1%4s$C0 $C2%8s$C0\"" ;;
            # TRACE)          eval "fmts=\"[$(timestamp)] $C1%4s$C0 $C2%8s$C0\"" ;;
        esac
        # if [ -n "${ENVE_PROGRESS:-}" ]; then
        #     fmts="$C1%4s$C0 $C2%8s$C0\\r"
        # fi
    else
        case ${ENVE_VERBOSE:-NOTICE} in
            CRIT|CRITICAL)  fmts="%4s %s:" ;;
            ERROR)          fmts="%4s %s:" ;;
            WARN|WARNING)   fmts="%4s %s:" ;;
            NOTICE)         fmts="%4s %s:" ;;
            INFO)           fmts="%4s %8s:" ;;
            DEBUG)          fmts="${ptime:+"[$ptime]" }%4s %2s %8s:"
                            print_fire_depth=true
                ;;
            TRACE)          fmts="${ptime:+"[$ptime]" }%4s %2s %8s:"
                            print_fire_depth=true
                ;;
            # DEBUG)          eval fmts=\""[$(date -u +"%D %T")] %4s %8s:"\" ;;
            # TRACE)          eval fmts=\""[$(timestamp)] %4s %8s:"\" ;;
        esac
    fi
    # shellcheck disable=2059
    if [ -n "$print_fire_depth" ]; then
        printf "$fmts" "$ENVE_PROGRAM_NAME" "${ENVE_FIRE_DEPTH:--}" "$1"
    else
        printf "$fmts" "$ENVE_PROGRAM_NAME" "$1"
    fi
}


# _COLS=
_format_tail() {
    str="$*"
    if [ -n "${ENVE_PROGRESS:-}" ]; then
        # if [ -z "$_COLS" ]; then
        #     _COLS=$(tput cols)
        # fi
        if [ $((${#str} + 30)) -gt 80 ]; then
            junk=${str#??????????????????????????????????????????????????}
            str="${str%"$junk"}..."
        fi
        fmts=" %s\\r"
    else
        fmts=" %s\\n"
    fi
    # shellcheck disable=2059
    printf "$fmts" "$str"
}

critical() {
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 6 ]; then
        _format_head "${LOGTYPE:-critical}" >&2
        # _format_tail "$@" >&2
        echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-critical}) $*" >&2
    fi
}
error() {
    _ERROR_MSG=${1:-}
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 5 ]; then
        _format_head "${LOGTYPE:-error}" >&2
        # _format_tail "$@" >&2
        echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-error}) $*" >&2
    fi
}

warning() {
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 4 ]; then
        _format_head "${LOGTYPE:-warning}" >&2
        # _format_tail "$@" >&2
        echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-warning}) $*" >&2
    fi
}

notice() {
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 3 ]; then
        _format_head "${LOGTYPE:-notice}" >&2
        _format_tail "$@" >&2
        # echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-notice}) $*" >&2
    fi
}

info() {
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 2 ]; then
        _format_head "${LOGTYPE:-info}" >&2
        _format_tail "$@" >&2
        # echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-info}) $*" >&2
    fi
}

debug() {
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 1 ]; then
        _format_head "${LOGTYPE:-debug}" >&2
        _format_tail "$@" >&2
        # echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-debug}) $*" >&2
    fi
}

trace() {
    _loglevel_form_symbol fast
    if [ "$loglevel" -le 0 ]; then
        _format_head "${LOGTYPE:-trace}" >&2
        _format_tail "$@" >&2
        # echo " $*" >&2
        # echo "$(_format_head ${LOGTYPE:-trace}) $*" >&2
    fi
}

log() {
    _loglevel_form_symbol fast
    require_loglevel=$loglevel
    ENVE_VERBOSE=${LOGLEVEL:-NOTICE} _loglevel_form_symbol fast

    if [ "$require_loglevel" -le "$loglevel" ]; then
        echo "$*" >&2
    fi
}

logtable() {
    # TODO: move this function to 'tablelib'
    _loglevel_form_symbol fast
    require_loglevel=$loglevel
    ENVE_VERBOSE=${LOGLEVEL:-NOTICE} _loglevel_form_symbol fast
    if [ "$require_loglevel" -le "$loglevel" ]; then
        while IFS="$tab" read -r vtype key value; do
            printf '%5s %15s %s\n' "$vtype" "$key" "$value" >&2
        done <<EOF
$1
EOF
    fi
}

fatal() { critical "$@"; }
_fatal() { critical "$@"; }
_critical() { critical "$@"; }
_error() { error "$@"; }
_warning() { warning "$@"; }
_notice() { notice "$@"; }
_info() { info "$@"; }
_debug() { debug "$@"; }
_trace() { trace "$@"; }

die() {
    trap - EXIT
    if [ -n "${1:-}" ]; then
        _error "$1"
    fi
    exit "${2:-1}"
}

print_tb() {
    _loglevel_form_symbol fast

    traceback_record=${traceback_record:-}
    if [ -n "$traceback_record" ]; then
        if [ "$loglevel" -le 2 ]; then
            # _format_head "${LOGTYPE:-error}" >&2
            echo "" >&2
            echo "Traceback:" >&2
            while IFS='*' read -r src func; do
                d=$src; fast_basename; src_base=$d;
                echo "  File $src_base, in $func" >&2
            done <<EOF
$traceback_record
EOF
        else
            e_src=
            e_func=
            while IFS='*' read -r src func; do
                e_src=$src
                e_func=$func
            done <<EOF
$traceback_record
EOF
            _format_head "${LOGTYPE:-error}" >&2
            d=$e_src; fast_basename; e_src_base=$d;
            echo " From file $e_src_base, in $e_func" >&2
        fi
    fi
}



settrace() {
    # trap '[ $? -eq 0 ] || echo err in $FUNCNAME in $BASH_SOURCE >&2' EXIT

    trap '
    retcode=$?
    if [ "$retcode" -ne 0 ]; then
        if [ ! -f "/tmp/enve-error-$ENVE_SESSION_ID" ]; then
            traceback_record=
            if [ -n "${FUNCNAME:-}" ]; then
                i=0
                while [ -n "${FUNCNAME[$i]:-}" ]; do
                    traceback_record="${BASH_SOURCE[$i]}*${FUNCNAME[$i]}${traceback_record:+$newl}$traceback_record"
                    i=$(( i + 1 ))
                done
            fi
            print_tb
            if [ "${_ERROR_MSG:-}" ]; then
                _error "${_ERROR_MSG:-}"
            else
                _error "Unexpected exit code $retcode"
            fi
            touch /tmp/enve-error-$ENVE_SESSION_ID
            if [ -n "${PRESS_ENTER_TO_EXIT_ERRORTRACE:-}" ]; then
                read -p "Press enter to continue"
            fi
        fi
    fi
    '"$(eval echo \$\*)" EXIT

    retcode=
    set -eu

    # if hascmd shopt; then
    #     # for posix-sh compative in bash, need bash>=4.4
    #     # shellcheck disable=2039
    #     shopt -s inherit_errexit >/dev/null 2>&1 || true
    # fi
}




