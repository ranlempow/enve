#!/usr/bin/env bash

array_remove() {
    eval declare -a array=("\${$1[@]}")
    eval declare -a delete=("\${$2[@]}")
    eval "$1=()"
    for i in "${!array[@]}"; do
        local match=
        for target in "${delete[@]}"; do
            if [[ ${array[i]} = "${delete[target]}" ]]; then
              match=1
            fi
        done
        if [ -z "$match" ]; then
            eval "$1=(\$$1 ${array[i]})"
        fi
    done
}


PM_HOME=$(dirname $0)
PM_FIFO=$PM_HOME/pm.fifo

rm $PM_FIFO
mkfifo $PM_FIFO

rm -rf $PM_HOME/procs
mkdir -p $PM_HOME/procs

# stopping=()
# declare -A states


x='
Note however that reloading a daemon by sending a signal (as with the example line above)
is usually not a good choice, because this is an asynchronous operation and
hence not suitable to order reloads of multiple services against each other.
It is strongly recommended to set ExecReload= to a command that not only triggers a
configuration reload of the daemon, but also synchronously waits for it to complete.


Note that ExecStartPre= may not be used to start long-running processes.
All processes forked off by processes invoked via ExecStartPre= will be
killed before the next service process is run.

Note that if any of the commands specified in ExecStartPre=, ExecStart=,
or ExecStartPost= fail (and are not prefixed with "-", see above) or
time out before the service is fully up, execution continues with commands
specified in ExecStopPost=, the commands in ExecStop= are skipped.


## ExecCmd Timing

|                   | sync  | until     |
|-------------------|-------|-----------|
| ExecRun           | run   | always    |
| ExecStart         | sync  | RUNNING   |
| ExecStartPre      | sync  | PREPARED  |
| ExecRestartPre    | sync  | STOPPED   |
| ExecStop          | sync  | STOPPED   |
| ExecStopPost      | sync  |
| ExecReload        | sync  | RUNNING   |
|
| ExecScript        | sync  | invoke with command "$ExecScript $ExecName"


start:
    RUNNING -> RUNNING
    STOPPED -> STARTING
            -> ExecStartPre -> .PREPARED    || STOPPED(STARTPRE_TIMEOUT)
            -> ExecStart(ExecRun)
            -> wait StartSec -> RUNNING

timeout or failed when start:
    STOPPED -> STARTING
            -> ExecStartPre -> .PREPARED    || STOPPED(STARTPRE_TIMEOUT)
            -> ExecStart(ExecRun) -> STOPPED(RUN_FAILED)
            -> ExecStopPost

restart:
    STOPPED -> = start
    RUNNING -> RESTARING
            -> ExecRestartPre -> .CHECKED   || RUNNING(RESTARTPER_TIMEOUT)
            -> ExecStop -> STOPPED          || RUNNING(STOP_TIMEOUT)
            -> ExecStopPost                 || STOPPED(STOPOST_TIMEOUT)
            -> wait RestartSec
            -> ExecStartPre -> .PREPARED    || STOPPED(STARTPRE_TIMEOUT)
            -> ExecStart(ExecRun)
            -> wait StartSec -> RUNNING

checked failed when restart:
    RUNNING -> RESTARING
            -> ExecRestartPre               || RUNNING(RESTARTPER_TIMEOUT)
            -> RUNNING(RESTARTPRE_FAILED|RESTARTPER_TIMEOUT)

stop:
    STOPPED -> STOPPED
    RUNNING -> STOPPING
            -> ExecStop -> STOPPED
            -> ExecStopPost

timeout or failed when stop:
    RUNNING -> STOPPING
            -> ExecStop -> RUNNING(STOP_TIMEOUT|STOP_FAILED)
            -> ForceKill -> STOPPED(KILLED)

reload:
    STOPPED -> STOPPED (exit 1)
    RUNNING -> RELOADING                    || RUNNING(RELOADING_TIMEOUT)
            -> ExecReload -> RUNNING


## directory structrue

pm.fifo
launchlock                          -> $launcher_pid        (global lock)
procs/$srv/launchlock               -> $launcher_pid $goal  (if operation is performing)
procs/$srv/launch.log
procs/$srv/try_pid                  -> $pid                 (by run $srv -- "$@" > pm.fifo)
procs/$srv/state                    -> $state $reason
procs/$srv/exitstate                -> $exitcode            (if $state == STOPPED)
procs/$srv/pid                      -> $pid                 (if $state == RUNNING)
log/pm.log


## lock

發動機首先要先取得全域鎖, 然後檢查所需要發動的各個服務能否鎖定,
如果無法將需要的服務鎖全部鎖定則放棄並離開,
如果可以將需要的服務鎖全部鎖定則全部鎖定之後放開全域鎖,

接下來開始依序執行各個服務的變動, 無論成功或失敗
每執行完一個服務, 就放開該服務的服務鎖

被lock的服務, 可以觀測狀態, 但狀態是無法確定的, 因為他的狀態正在改變中


## dependency

|               | propagation       | requiremnet   |
|---------------|-------------------|---------------|
| Require       | start             | RUNNING       |
| Requisite     | -                 | RUNNING       |
| Wants         | start             | -             |
| BindsTo       | start, <-stop     | RUNNING       |
| PartOf        | stop, restart     | -             |
| AlsoReload    | reload            | -             |


## propagation

start傳播   -> 底層先start, 上層才start
stop傳播    -> 上層先stop, 底層才stop
restart傳播 -> 上層stop, 底層stop, 底層start, 上層start
reload傳播  -> 底層先reload, 上層才reload



## config as state & hot deploy

1. commit code to git and push to server reposity
2. ssh send command: deploy from reposity
3.   pm-image: relink images
4.   pm: detect deployment change
5.   pm: restart relative service
6. ssh send command: check deploymnet result
7. ssh send command: if any wrong maybe rollback



## pstree

linux:
    systemd > tini > pm > srv
    systemd > tini > pm > sshd > bash > pm-launch

macos:
    pm-sim > pm > srv
    bash > pm-launch

即使在linux也有辦法以 pm-launch 來重新啟動整個 pm, 同常是用在重新部署pm本身,
做法是讓 pm 行程結束時回傳 60, 而 systemd 或是 pm-sim 收到 exitcode 60 之後要重新啟動底下的服務
重新部署的風險很大, 如果部署失敗, 則無法再從ssh登入, 最好能重新部署到確定能運作的版本


group or subdeploy:
    systemd > tini > pm > pm > subsrv




## ini設定檔

[service.$service]
state=STOP|START
execDeploy=

execRun=
execStart=
execStartPre=
execStartPost=
execRestartPre=
execStop=
execStopPost=
execReload=

require=
requisite=
wants
partOf=
reloadTo=


[group.$group]
execStartPre=
execRestartPre=
execStartPost=
execStopPost=


# state loop

signal => state_machine => change_state & exec => signal => ...


# state list

RUNNING
STOPPED

STARTING
STOPPING
RELOADING
RESTARING

RESTART_CHECKING
START_PREPARING

STOPPED.SCHE_START
RUNNING.SCHE_STOP
RUNNING.WANT_RESTART
RUNNING.SCHE_RELOAD

START_FAILURE
RUN_FAILURE
STOP_FAILURE
RELOAD_FAILURE
RESTART_FAILED
STOPPED.FAILED
FATAL


# input list

timeout
dependExist
dependQuit
dependFail
startRequest[.depended]
stopRequest[.depended]
restartRequest[.depended]
reloadRequest[.depended]
conditionPass
conditionFail
processGone


# transition table


STOPPED/startRequest                -> STOPPED.SCHE_START   => startDependencies
STOPPED.SCHE_START/dependExist      -> START_PREPARING      => execStartPre
STOPPED.SCHE_START/dependFail       -> STOPPED              => dependFail


START_PREPARING/conditionPass       -> STARTING             => execRun
START_PREPARING/conditionFail       -> START_FAILURE        => dependFail
START_PREPARING/timeout             -> START_FAILURE        => dependFail
STARTING/conditionPass              -> RUNNING              => dependExist
STARTING/conditionFail              -> START_RETRYING
STARTING/timeout                    -> WAIT_START_RETRYING
WAIT_START_RETRYING/timeout         -> START_RETRYING
WAIT_START_RETRYING/stopRequest     -> STOPPED              => dependFail
START_RETRYING/conditionPass        -> RUNNING              => dependExist
START_RETRYING/conditionFail        -> WAIT_START_RETRYING
START_RETRYING/retryExceeded        -> START_FAILURE        => dependFail


RUNNING/resourceGone                -> STOPPED.FAILED       => forceStopDependencies
STOPPED.FAILED/stopRequest          -> STOPPED              => execStopPost
STOPPED.FAILED/timeout              -> STOPPED              => execStopPost
STOPPED.FAILED/restart.timeout      -> STOPPED.SCHE_START


RUNNING/stopRequest                 -> RUNNING.SCHE_STOP    => stopDependencies
RUNNING/restartRequest              -> RUNNING.WANT_RESTART => execRestartPre
RUNNING/reloadRequest               -> RUNNING.SCHE_RELOAD  => reloadDependencies

RUNNING.SCHE_STOP/dependStopped     -> STOPPING
STOPPING/conditionPass              -> STOPPED              => execStopPost
STOPPING/conditionFail              -> STOP_FAILURE


RUNNING.WANT_RESTART/conditionPass  -> STOPPING.RESTARING
RUNNING.WANT_RESTART/conditionFail  -> RESTART_FAILURE
STOPPING.RESTARING/conditionPass    -> STOPPED.SCHE_RESTART => restartDependencies
STOPPING.RESTARING/conditionFail    -> STOP_FAILURE.RESTARING
STOP_FAILURE.RESTARING/processGone  -> STOPPED.SCHE_RESTART => restartDependencies

STOPPED.SCHE_RESTART/dependStopped  -> STOPPED.WAIT_RESTART => timer
STOPPED.WAIT_RESTART/timeout        -> STOPPED.SCHE_START

RUNNING.SCHE_RELOAD/dependReloaded  -> RUNNING.RELOADING    => execReload
RUNNING.RELOADING/conditionPass     -> RUNNING
RUNNING.RELOADING/conditionFail     ->
RUNNING.RELOADING/timeout           ->


STOP_FAILURE/timeout -> FATAL
STOP_FAILURE/processGone -> STOPPED


'



. enve define
TABLE="$(parse_config "$(root="$(dirname "$0")" resolve_path "pmcfg_example.ini")")" || die "parse_config error"
echo "$TABLE"

service_names="$({ table_subset "service\..*" || true; } |
                 as_postfix "service\." | as_rootkey | as_uniquekey | tr "$newl" " " )"
cmdwarp_names="$({ table_subset "cmdwrap\..*" || true; } |
                 as_postfix "cmdwrap\." | as_uniquekey | tr "$newl" " " )"

ALL_EXEC_ACTIONS="execDeploy execRun execStart execStartPre execStartPost execRestartPre execStop execStopPost execReload"
ALL_EXEC_ACTIONS_REGEX="$(echo $ALL_EXEC_ACTIONS | tr ' ' '|')"
echo "$service_names"
echo "$cmdwarp_names"


function wrap_exec_statment() {
    table_exclude "service\..*\.($ALL_EXEC_ACTIONS_REGEX)" |\
    while read -r key value; do
        out_var_fast "$key" "$value"
    done
    for name in $service_names; do
        while read -r key value; do
            for wrap in $cmdwarp_names; do
                extend=
                value_without_extend="${value%\~}"
                [ "$value_without_extend" != "$value" ] && {
                    extend=' ~'
                }
                eval "set -- $value_without_extend"
                if [ "$1" = "$wrap" ]; then
                    # func="$(table_tail "cmdwrap\.$wrap")"
                    # echo 's/$2/'"${3:-}"'/g'
                    value="$(table_tail "cmdwrap\.$wrap" | \
                             sed -e 's/$1/'"${2:-}"'/g' \
                                 -e 's/$2/'"${3:-}"'/g' \
                                 -e 's/$3/'"${4:-}"'/g' \
                                 -e 's/$4/'"${5:-}"'/g' \
                                 -e 's/$5/'"${6:-}"'/g' \
                                 -e 's/$6/'"${7:-}"'/g'
                                 )$extend"
                fi
            done

            out_var_fast "$key" "$value"
            :
        done < <({ table_subset "service\.$name\.($ALL_EXEC_ACTIONS_REGEX)" || true; })
    done
}


function merge_exec_statment() {
    table_exclude "service\..*\.$ALL_EXEC_ACTIONS_REGEX" |\
    while read -r key value; do
        out_var_fast "$key" "$value"
    done
    for name in $service_names; do
        for exec_name in $ALL_EXEC_ACTIONS; do
            EXECRUN_TABLE="$(table_subset "service\.$name\.$exec_name")"
            if [ -z "$EXECRUN_TABLE" ]; then
                continue
            fi
            EXECRUN_TABLE="$(echo "$EXECRUN_TABLE" | while read -r key value; do
                if [ "${value%\~}" != "$value" ]; then
                    out_var_fast "$key" "${value%\~}"
                else
                    out_var_fast "$key" "$value$feed"
                fi
            done)"
            echo "$EXECRUN_TABLE" | as_value | as_concat | tr "$feed" "$newl" |\
            while read -r line; do
                out_var_fast "service.$name.$exec_name" "$line"
            done
        done
    done
}

TABLE="$(wrap_exec_statment)"
TABLE="$(merge_exec_statment)"
echo "$TABLE"




# while read -r name; do
#     echo "$name"
# done < <()

exit 1


tmux_relate() {
    tmux -S /tmp/tmux/pm.socket start-server
    tmux detach
    tmux attach -t XXXX
    tmux new cmd args
    
}


while true; do
    while read -t 0.001 cmd arg1; do
        case $cmd in
            start)
                    sleep 1000 &
                    pid=$!
                    echo RUNNING > $PM_HOME/procs/$pid
                ;;
            stop)
                    pid=$arg1
                    if [ -f $PM_HOME/procs/$pid ]; then
                        kill -TERM $pid
                        echo STOPPING > $PM_HOME/procs/$pid
                    fi
                ;;
            restart)
                ;;
            reload)
                    kill -HUB $pid
                ;;
        esac
    done < $PM_FIFO
    
    # for pid in "${states[@]}"; do
    # done

    while read -r pidpath; do
        pid=$(basename $pidpath)
        state=$(cat $pidpath)
        case $state in
            STOPPING)
                    if ! { jobs -p | grep $pid; }; then
                        wait $pid
                        exitcode=$?
                        echo EXIT $exitcode > $pidpath
                    fi
                ;;
        esac
    done < <(find "$PM_HOME/procs" -mindepth 1)
    sleep 1
done
