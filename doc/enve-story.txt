curl --max-time 20 --head -x tanet.proxy.shu.edu.tw:3128 -L http://github.com

# evne特色


1.無依賴免設定安裝一應俱全
2.posix
3.pure從版本控制開始
4.out of source operations
5.高效能
6.安全性


# 幾大重點API

enve_fire
cache_build
dest=$(
    fetch "git+$url#$branch" %cache dir
)


# 再次釐清

bare Infrastructure 自建基礎設施
IaaS  使用基礎設施
PaaS  使用平台
SaaS  使用軟體


使用者
administrator 管理員, 維護機器或網域
architect 架構師, 負責部署藍圖
operator 操作員, 負責進駐計畫

物件
domain 最上層概念
commit 工廠所量產的產品
config 出廠後使用者的設定
plan 各產品聯合部署的方式
machine 房間屬於某個建築物, 這個建築物可能不在討論範圍
node 收容產品的房間
spot 房間中安插產品的地點
blueprint 各建築物與房間的配置方式, 可能包含系統安裝
repository 集中放置產品的地方, 也可以放置計畫或藍圖


blueprint:
  node <-> spot
  node <-> keys

plan:
  spot <-> config
  spot state
  sign

deploy blueprint to node
march plan to spot


deploy 需要透過ssh或是本機命令執行
march 只需要做串流寫入

repository 有安裝鎖孔
node 必須用鑰匙才可以取得config或commit
node 內必須安裝一個以上的鎖孔
operator 時必須持有鑰匙才可進行 march



# 軟體

一個運作中的系統由運行中或即將運行的軟體所組成
system = runnableSoftware*
system = physicalNode* + commits* + cohesion


可運行的軟體是可以被重新配置而改變行為的
runnableSoftware = configure(config, runtimeDep, configurableSoftware)
configurableSoftware = install(physicalNode, installDep, installableSoftware)
installableSoftware = build(platform, buildDep, buildableSoftware)

而可建造的軟體是master分支的其中一個提交
commit on codebase = buildableSoftware(總之就是潛在的runnableSoftware)

(runtimeDeps, installDeps, buildDeps) are runnableSoftwares


runnableSoftware = commit + config + deploy(physicalNode)
runnableSoftware = (commit + config) + deploy(physicalNode)
runnableSoftware = commit + (config + deploy(physicalNode))
runnableSoftware = preconfig-commit + preconfig-physicalNode


__configure__ means modify the physical node setting, add or remove nodes.
__deploy__ means _install_ and _setup_ a tested software on node.
__release__ means change production software behavier includes update, rollback or reload setup.
__install__ means upload artifact to machine of node and unpack to destination directory, then do some necessary preprocess.
__setup__ means change behaiver or preforemance of software, that is designed to be changable properties.


## configure
部署Node所需要的資訊
1.Node的 PGP key
2.rootca的 PGP public key (用來簽證configer的PGP key)
3.通道url列表 (file, http, https, dnstxt)
4.基本配置 (例如可用資源限制, 但這不是必須的)

Node不需要開啟任何port,
也不需要暴露自己的IP(必要時可以用proxy來增加隱蔽性), 就可以配置自己
而整個流程也不一定需要中央伺服器, 可以是一個可修改的dns, 或是一個公有服務
Node所要做的只是開機後連線到一個已知的url並透過此網站來交換配置資訊
該url也可以是本地檔案, 這代表configer擁有上傳檔案到Node的手段
一旦Node可以bootstrap之後, 他所開啟的服務, 會將configer控制權大幅的擴張
安全性的關鍵在於configer的PGP key不能被竊取並破解

每個spot都有專屬目的資料夾, 即時同一份部署, 要安裝到多個spot也會安裝成多個資料夾
例如, 有3個spot都安裝某軟體的3個版本, 那總共會有9個目的地資料夾


## checkout

建造的前一個動作, 從版本庫取得特定的版本, 或是直接從url下載後解壓縮

noop的情形: 使用本地unpure資料夾

## build

noop的情形: 直接從checkout出來的目錄執行

## settle

佈置chroot過去的空間, 包含根目錄, 使用者, jail, namespace
額外磁區mounts
網路佈置

noop的情形: 不需要chroot的情形

## install

首先要settle space

安裝到 unpure 的資料夾
run之前, 如果該目的地資料夾的安裝與要求不同, 則會進行重新安裝, 或是使用之前的安裝
run途中, 如果plot的安裝改變了, 則service需要restart

要安裝的除了建造出來的軟體本身, 還包括runtime依賴

noop的情形: 直接從checkout出來的目錄執行


## setup

對 unpure 資料夾進行設定, 這個設定可以多次實行而不改變效果
設定也會蓋掉上一次的設定
run之前, 如果該目的地資料夾的設定與要求不同, 則會進行重新設定
run途中, 如果目的地資料夾的設定改變了, 則service需要reload

noop的情形: 完全使用預設setup, 或是完全沒有configfile的情形


## run

通常run之前會馬上進行setup
也早就已經透過install安裝所需依賴


## execute

與run的差別在於不能自訂要跑的command


## targets 各個操作的依賴關係

final -> setup -> install -> settle -> checkout?
                   |
                   v
          test ->  build -> checkout


### procedure(modules)
checkout: builtin+first
parse:    builtin
load:     builtin
settle:   builtin   checkout?
build:    exec      checkout
install:  builtin   checkout build settle
setup:    builtin   checkout build settle install
final:

### final target
run:      exec      checkout build settle install setup
module:   exec      checkout build settle install setup
test:     exec      checkout build [[settle install] setup]
shell:    builtin
execute:  exec



checkout(url) -> sdir
paser(sdir/conf) -> pTABLE
load(pTABLE) -> lTABLE with ordered module execution
build(genrcfile(pTABLE)) -> cache/artifact with bTABLE

settle(pTABLE) -> sTABLE with root
install(pTABLE with root, artifact with bTABLE) -> iTABLE with installed_mark
setup(pTABLE with root) -> uTABLE with setup_mark

final(genrcfile(uTABLE with root))


proc            cond    hash                    vaild       make
--------------------------------------------------------------------
final-rc        -       url|profile             rc+marks    genrcfile
  checkout      url     url|profile             -           fetch
  paser&load    -       -
  settle        m       sub(s, pTABLE)          rootmark    settle
  install       m       sub(i, pTABLE)+artifact installmark unpack
    build       mins    sub(b, pTABLE)+source   artifact    fire build
      build-rc  mbui    sub(b, pTABLE)          rc          genrcfile
  setup         m       sub(u, pTABLE)          setupmark   setup







## pm spot

STOPPED - startCmd -> SCHE_START - dependOk -> STARTING - sync_or_condition
                   -> RUNNING

condition:
- pid file found
- wait a little time, process still exist

SCHE_START.dependExistFail -> STOPPED
STARTING.conditionFail -> STARTING_FAIL
STARTING_FAIL.timeout -> STOPPED

RUNNING - stopCmd -> SCHE_STOP - dependQuit -> STOPPING - sync -> STOPPED

RUNNING.processGone -> FAIL
FAIL.timeout -> STOPPED


## 其他資源

Install @ Root
Setup @ Root
Volume (Root) @ Root
Network

其他資源跟行程服務並無差異
都是透過pm invoke來發起
差別在於pm main並不檢查pid, 而是使用execCheck來確定資源是否還存在


## enve makepkg
use fakeroot to make tar file


## enve store

這個store是install的預設目標路徑
主要是提供cache性質般的儲存方式

使用者必須提供 1.需求文本(作為快取用) 2.確認過期(不是必須的) 
            3.重現方法(不是必須的) 4.catalog=any
            5.user=$USER 6.title=none 7.保密性private=


有時候1與3是相同的東西

首先根據文版算出快取$hash
接下來搜尋路徑 $STORE/($user|root)[-private]-$catalog[-{0,1,2,3}]/$hash-$title
如果有找到則回傳, 否則
找到持有寫入權限的資料夾 $STORE/[$user-]$catalog[-{0,1,2,3}]
沒有的話根據$private建立一個自己的快取資料夾, 再來
建立目的資料夾, 執行製作方法並把環境變數OUT設定為該目的資料夾

比起nix-store有以下不同的特性
1.ownership不限於root(因此非root用戶也可以進行安裝)
2.可以內含setuid的執行檔
3.檔案預設是readonly, 但是資料夾預設不是readonly
4.不一定使用固定的檔案時間戳記
5.不一定採用資料夾內容的hash來作為項目的名稱, 也可能採用其他內文的hash
6.盡量不使用symlink, 如果要有dependency的概念, 使用文字檔取代symlink
7.不一定是immutable的


## pm mount

mount bind
mount tmp
(X)mount loop



## pm subroot

建立可以被chroot的資料夾




## pm 與 enve

pm會對以root的設定來對firechain中的install與setup拆分出另外的service

software-v1.0!build <-
  !install@$root.service|cachedir <-
    !setup@$root.service <-
      !run@$root.service

請注意setup是排斥的, 可以多個版本install到同一個root,
但是不能多個版本setup到同一個root

如果要setup多個版本多個實體, 有幾的方法

1. 分隔root
2. 使用獨立的config設定

例如:

    software-v1.0!setup@$cfgpath1@$root.service <-
      software-v1.0!run@$cfgpath1@$root.service

    software-v1.0!setup@$cfgpath2@$root.service <-
      software-v1.0!run@$cfgpath2@$root.service

不使用獨立root的情形, 要確保同一個root中的各個setup不會產生衝突

build的結果只會存放在cache, 所以與root無關

install 與 root 可以同時存在或是無關(因為安裝在cache, nix), 而且Idempotence
insA -> insB -> insB  == insA + insB
setup 與 root 不能同時存在, 但也是Idempotence
setA -> setB -> setB  == setB



## pm 無狀態

文本監視者 --發送新部署--> 部署狀態持有者 --差異命令流--> pm狀態機
pm的狀態保存在文件系統和作業系統之中


## pm 狀態結構

PMHOME=/var/opt/pm

$PMHOME/jobs/$JOBID/parameter - 發起前寫入, 發動的參數與理由, table格式, debug用
$PMHOME/jobs/$JOBID/pid - 發起成功後寫入
$PMHOME/jobs/$JOBID/retcode - 結束後寫入

$PMHOME/units/$UNITID/parameter - UNIT的設定值, 可以被更動
$PMHOME/units/$UNITID/state - 當時的fsm狀態

$PMHOME/input - input fifo


## fatal of pm (當機)

pm 會記錄所有衍生的子行程, 一但當機, 監視行程會消滅所有子行程
然後監視行程再退出

## pm terminal (main模式之一)

打開一個代表pm的terminal並且打開預設shell
監視行稱會監視該shell有沒有退出
某些服務可以掛在tmux底下, 可以打新的terminal來連結到某個服務

pm shell <---> enve shell
一個整合式的開發環境


## pm dispatch

根據來源資訊, 設定各個pm的資源
因此pm可以單純化為接受輸入的狀態機

可以在dispatch期間融合spot和firechain的內容

pm dispatch 的特化版本還可以偵測兩個版本的變化(diff)來發出指令




## pm inventory

inventory 儲存著各個remote, 每個remote的特色就是有/var/pm/default.pipe
pm 可以一次列出所有遠端機器的資源狀態
並且可以利用 remote.pm1.pm2.pm3.serviceA 的方式來參照各個資源

inventory 可以是遠端也可以是localdir


## pm client

發送命令到name pipe之後, 監視pm server的進度
一邊回報相關的進度, 等達到完成點後, 設定retcode後退出

start|stop|reload|restart
try-restart             only if running
reload-or-restart
try-reload-or-restart
cat                     show property
set-property
reset-failed
list-dependencies

(X) pm client 與 pm dispatch 是同類型功能的不同機制

pm client ---> pm dispatch ---> pm.socket (pm fsm) ---> pm launch


## pm inovke




## pm syssrv

pm 可以自我部署到系統中來進行首次的boostrap
這讓更上層的作業系統可以自動喚起pm

計畫可以支援的平台有
- cygrunsrv
- systemd
- BSD-style init(8)
- launchd
- pm (非自動偵測)

除了pm host本身以外其他平台只能註冊一個pm service
因此如果需要多個pm service必須以一個pm host當主機
系統級的pm以root權限啟動, 如果要隔離namespace, 則在pm slave中進行隔離


支援的動作有
host install --force --init-stream XXX --stdout YYY --as-root
host remove
host start
host stop

pm boot 之後需要初始的命令流, 否則整個pm會不含任何service而陷入被動模式

這個部署很簡單, 就是把特定檔案放置到系統中的位置.


## pm sub (main模式之一)(遞迴)

pm 本身也是一個可部署的行程, 支援所有pm invoke協定
特別的地方是, parent-pm 知道 sub-pm 的 socket, 所以可以對 sub-pm 單向命令
也由於知道 sub-pm 的 PM_ROOT 還有完整的檔案系統root, 所以可以取得 sub-pm 的內部狀態


隔離假設, 切換到nobody使用者之後chroot
需要使用root來執行這些程式碼, 因此pm不能在非末端userpm的情況下遞迴

rootpm|chroot_rootpm -> rootpm|jail_rootpm|chroot_rootpm|chroot_userpm|userpm
jail_rootpm -> jail_rootpm|chroot_rootpm|chroot_userpm|userpm
userpm|chroot_userpm|jail_userpm -> userpm

簡單來說由於U不能接續R, 所以
(O) RU, RRU, RRRR, UUUU, RRUU
(X) UR, RUR, RURR, URRR


rootpm|jailrootpm -> jailrootpm 需要特殊工具
rootpm|jailrootpm -> chrootpm 只需要 chpd

## pm attach

連接mount資源的方式?


## configure loader (pm main)
--init-stream 通常會設定一個 configure loader service 掛在pm底下

幾種基本的 cfg loader

- 從特定檔案
- 從特定網址
- 接收特定軟體的遠端指令 (ex: k8s)

cfg loader會獲得指令後傳送給上層的pm master



# Automated provisioning using apkovl 

This can be done by specifying apkovl= in the kernel command line


# [不該在這裡的章節] wrapped enve

parent enve依賴 child enve, 但其實是 parent 是要改變或設定 child

# [不該在這裡的章節] enve handler

中介處理並轉換enve的enve

# [不該在這裡的章節] machm ovl

ovl 是系統部署方式
ovl 是一個tar檔案, 內部含有/etc等等設定檔, 會在開機initramfs時覆蓋root
ovl 可以是openssl 加密的 base64 的 zlib 壓縮的 tar檔案
ovl 可以是一個url, initramfs會掛載網路, 並且嘗試下載
tar內可以有 /layers 資料夾裡面的子資料夾如下格式
$NN-$favor1[-$favor2...], 一旦所有的favor都符合, 將會$NN順序套用到root中
有以下幾種favor可用
MAC_ADDRESS     /sys/class/net/$device/address
MACHINE_UUID    /sys/class/dmi/id/product_uuid
VOLUME_UUID
KERNAL          $(uname -s)
KERNAL_RELEASE  $(uname -r)

因此一個檔案就可以包含各種不同作業系統與版本全部機器的設定檔, 可以一次完成上傳
而且由於是base64加密文字格式, 很容易上傳到github-gist之類的公開場所

在linux中 root 必須是 btrfs 否則必須施加overlayfs
在bsd中 root 必須是 zfs


每次開機initramfs時, 會設定overlay, 關機後overlay會被自動刪除
因此系統總是自動部署, 自動還原

ovl 除了放在公開網路上, 也能放在分區中特定的位置, ex: btrfs:/@ovls/$ovl
ovl 內可以含有機器的金鑰, 這很重要


# [不該在這裡的章節] machm mksys

新安裝作業系統在特定的磁區, 並且設定grub.cfg
可以設定定期安裝, 例如每兩週安裝一次, 一但重開機就會自動轉換到新的kernal
一但發生問題也能透過grub.cfg的開機選單來還原

必須有efi磁區裡面安裝grub, 開機方式可以是gpt+bios或是gpt+efi
在linux中 root 必須是 btrfs 否則必須施加overlayfs
在bsd中 root 必須是 zfs

安裝的系統必須支援ovl



