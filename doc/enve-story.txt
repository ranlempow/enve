curl --max-time 20 --head -x tanet.proxy.shu.edu.tw:3128 -L http://github.com

#Finish:
(X)在rcfile加入enve bootstrap cdoe
(X)在rcfile加入cache invaild code
(O)解決enve.module的錯誤處理流程
(O)更美好的輸出格式, 尤其是pretty pring TABLE, 提示FIRE_LEVEL
(O)gui launch, terminal launch, enve.ini click
(O)auto find default target at enve.ini shebang
(O)正確的跨平台shebang為 '#!/usr/bin/env enve'
(O)進度條logging模式
(O)terminal模式開啟時, 發生錯誤時要press enter to continue
(O)read -p "Press enter to continue" use in many place
(O)detect interactive more smart
    # System-wide .bashrc file for interactive bash(1) shells.
    if [ -z "$PS1" ]; then
        return
    fi
(O)boot/enve.ini to $ENVE_HOME/evne/preset/boot.enve
(O)project name from $PRJ_NAME.enve.ini
(O)shell.setopt
(O)enve boot zsh, (O)boot script to system rc
(O)grep: empty (sub)expression

#TODO: setups

1. (O)nix|(?)cygwin
2. (O)homebrew
3. (O)sublime-text|(O)sublime-merge
4. (O)terminal (O?)tmux
5. git - by clone
6. ssh
7. enve


system level
user level
workspace level
project level
environ level


#TODO: autologin

(O)google -> get-sheet-inventory
(O)github -> git-clone-config
--------
redns(aws)
lets-encrypt(acme.sh)
ssh
sshd



#TODO
enve ws
enve project open - autosave shell enve, and can be reenter by interactive selecting
enve project clone
enve ssh-add - start ssh-agent & add key from $ENVE_USERHOME/.ssh/id_XXX

(X)define.module.base-system.module.args
(O)call module with MODULE_NAME set

sidecar with livebound:
    tmux:
    sshd:  /usr/sbin/sshd -D -d -h ~/sshd-key/ssh_host_rsa_key
    ssh-agent
    psk-agent

sidecar with tmux

(O)module import *ALTER*
psk.setup

boot tmux
boot zsh-tmux
boot security-center

(O)ENVE_RCRESOLVE_PIDFILE - write pid to ENVE_RCRESOLVE_PIDFILE when run rcfile
(O)Deprecated import

https://jichu4n.com/posts/debug-trap-and-prompt_command-in-bash/
hook pre_prompt
hook post_prompt


clipboard operation:
someCommand | pbcopy
someCommand | C:\Windows\system32\clip.exe
someCommand | xclip -i -selection clip > /dev/null

Bash completion has been installed to:
  /usr/local/etc/bash_completion.d

zsh completions have been installed to:
  /usr/local/share/zsh/site-functions

to nodejs package-lock.json lack on userhome

HOMEBREW_CASK_OPTS='--appdir='"$HOME"'/Applications' brew cask install


discretescroll                   openemu                          virtualbox
firefox                          osxfuse                          virtualbox-extension-pack
font-hack-nerd-font              steam                            xquartz
google-chrome                    sublime-merge
java8                            sublime-text


$HOME/
- workspace
  - config(XDG)
  - secret/db
  - home
    - profile/*.evne.ini
    - sublime/*.sublime-project
  - local (Caskroom bin include opt sbin var Cellar Homebrew etc lib share)
    - enve/.git
    - Homebrew/.git
    - var/log
    - var/run (XDG_RUNTIME_DIR)
    - var/lib: holds state information pertaining to an application or the system
      - sublime/*.sublime-project
  - project
    - P1/.git
    - P3/.git
  - extra
    - P1/*.txt
    - P3
  - out/P1
  - sub/P1/project/P2/.git
  - sub/P1/out/P2
  - sub/P1/download
  - sub/P1/sub/P2/project/P4/.git
  - sub/P1/sub/P2/sub/P4/project/P5/.git



#TODO tier1:
(Go~)dictionary在程式碼中標定
(Go~)加入更多的info, debug, warnning
(O)kitty config, macos terminal theme
(Going)use 'false; return 1' at error raise, subshell 要加入 settrace
(O)basename, dirname 使用快速版本

(O)prompt & (O)title

(O~isotable)dummy isolator(piso) API, 使用另外iso.table檔案傳遞訊息

(O)loader回傳的module分組, 而且提供排序提示, module.$procedure
    (O)in oh-my-zsh/enve.module/gencode set CONDA_DEFAULT_ENV to prject_name
    (O)取消loader module傳入"$0"
    (O)合併module所提供的boundfile
    (O)測試與使用module_sort_after

(O)multiple .module file in a module dir, share same enve.ini

(X)enve clone介面, 先放在urlutils
(O)is_url
    (O)inherit, import, with lazy, 延後到resolve前期執行
    (O)-c也延後到resolve前期執行
    (O)-c順序有影響, 在-f之前為提供預設值, 在-f之後為覆蓋
    (O)這個順序在import, include, 也會採用相同的做法
    (O)利用ENVE_CONFIG_PRE_XXX, ENVE_CONFIG_XXX影響環境中的子環境


(O)新增SEC變數類型, 這些變數不會寫入rcfile, 每次都要重新求值, sec.variable

(O)定義procedure與target之間的關係
    (O)procedure序列, 各種procedure target
    (Go~)在config指定網路檔案下載到cache或特定資料夾
    (O)pyenve (O)ruby (O)nodejs 要使用cache
    (O)制度化/out/$prjname, $PRJ_OUT
    makefile試做
    (contribute)xcode, android, cmake

build.version|build.tag 可以自訂輸出的資料夾名稱, 也可以達成多輸出

提供範例
    python+cython+c, 建造雙輸出範例
    curl-client+nodejs-server+mongodb+aws, 伺服器開發環境範例, 雙部署
    android+ios, 手機開發環境範例
    簡單的ci範例

(O)move enve project to projects


#TODO:
(X)change enve.ini to project.enve
tutor framework
sshd ForceCommand, SSH_ORIGINAL_COMMAND
example/remake/remake.enve.ini

meta.*, meta模式, restrict模式(meta.restrict), meta.offline(no curl)
meta.$subprogram.version
meta.independant(不會include使用者預設的enve)

(O)isolator改良刪除不用的程式碼
(O)isolator與settle分離

dfork定案與初步測試
amazon s3
enve deploy system



# prompt & title & hotkey & color
bash + TERM_PROGRAM=Apple_Terminal
bash + xterm-mintty
bash + kitty
(prompt-OK)bash + ssh + kitty
zsh + TERM_PROGRAM=Apple_Terminal
zsh + xterm-kitty
zsh + mintty
zsh + pure + TERM_PROGRAM=Apple_Terminal
zsh + pure + xterm-kitty
zsh + pure + mintty
zsh + pure + tmux + TERM_PROGRAM=Apple_Terminal
zsh + pure + tmux + xterm-kitty
zsh + pure + tmux + mintty
(hotkey-color-OK)zsh + pure + tmux + ssh + TERM_PROGRAM=Apple_Terminal
(hotkey-color-OK)zsh + pure + tmux + ssh xterm-kitty
zsh + pure + tmux + ssh mintty

use `kitty +kitten ssh myserver`





安裝mac到120G硬碟
安裝windows 10 到120G硬碟


#未來
shell.welcome, 以及腳本化welcome, 與git整合
terminal.title, 腳本化
enve.module更名?
(O)nix移到core/nix, 可能兼容unix.*
git-hook簡易整合, enve clone
rtmux.session.$SNAME.pane.$PNAME=[enve]

autojump
oh-my-zsh local with filename https://github.com/rupa/z
https://github.com/junegunn/fzf
https://github.com/pre-commit/pre-commit



#收尾
more test
統一'_info', 'info', '_log', 'log'
(O)偵測variable lack的問題
預設的logging level到底要怎麼設定
(O)change #!/bin/bash -> #!/usr/bin/env bash 或是 #/bin/sh
(O)全面進行editorconfig檢查, 換行檢查, 字元檢查, 行尾空白檢查


# evne特色

一個基於命令列的整合開發環境
一個套件管理器的套件管理器
一個runc執行器(apprunner)
一個init, 或是行程管理器, 或是資源管理器


1.無依賴免設定安裝一應俱全
2.posix
3.pure從版本控制開始
4.out of source operations
5.高效能
6.安全性
7.可以達成Multi-stage continuous integration
8.跨平台(windows平台)


# 幾大重點API

enve_fire
cache_build
dest=$(
    fetch "git+$url#$branch" %cache dir
)


# 201908


            prefix    dependency  maintain    location    autoimport sh_module
core/       optinal   enve-libs   enve-owner  enve-repo   yes        require
contrib/    optinal   posix       contributor enve-repo   yes        optional
thirdparty/ optinal   no resist   other       public-repo no         optional

thirdparty maintain a ordered key-value map module name to module repository url.

autoimport is done by maintain a key-name list


isoexec
dlexec



# 再次釐清

bare Infrastructure 自建基礎設施
IaaS  使用基礎設施
PaaS  使用平台
SaaS  使用軟體


使用者
administrator 管理員, 維護機器或網域
architect 架構師, 負責部署藍圖
operator 操作員, 負責進駐計畫

物件
domain 最上層概念
commit 工廠所量產的產品
config 出廠後使用者的設定
plan 各產品聯合部署的方式
machine 房間屬於某個建築物, 這個建築物可能不在討論範圍
node 收容產品的房間
spot 房間中安插產品的地點
blueprint 各建築物與房間的配置方式, 可能包含系統安裝
repository 集中放置產品的地方, 也可以放置計畫或藍圖


blueprint:
  node <-> spot
  node <-> keys

plan:
  spot <-> config
  spot state
  sign

deploy blueprint to node
march plan to spot


deploy 需要透過ssh或是本機命令執行
march 只需要做串流寫入

repository 有安裝鎖孔
node 必須用鑰匙才可以取得config或commit
node 內必須安裝一個以上的鎖孔
operator 時必須持有鑰匙才可進行 march


# 組件

runc/enve 封裝物執行器, 具有isolate功能

pm 行程管理
nodep node部署器/安裝器, 連結作業系統service
noded pm序列發射器, plan讀取器
march plan產生器, plan放置器


# 關於測試 - What to test
(這一段主要在講好的測試環境的要求, 不是很重要)

Testing tools can help automate tasks such as product installation, test data creation, GUI interaction, problem detection (consider parsing or polling agents equipped with test oracles), defect logging, etc., without necessarily automating tests in an end-to-end fashion.

One must keep satisfying popular requirements when thinking of test automation:

1. Platform and OS independence
2. Data driven capability (Input Data, Output Data, Metadata)
3. Customization Reporting (DB Data Base Access, Crystal Reports)
4. Easy debugging and logging
5. Version control friendly – minimal binary files
6. Extensible & Customization (Open APIs to be able to integrate with other tools)
7. Common Driver (For example, in the Java development ecosystem, that means Ant or Maven and the popular IDEs). This enables tests to integrate with the developers' workflows.
8. Support unattended test runs for integration with build processes and batch runs. Continuous integration servers require this.
9. Email Notifications like bounce messages
10. Support distributed execution environment (distributed test bed)
11. Distributed application support (distributed SUT)



# 軟體

一個運作中的系統由運行中或即將運行的軟體所組成
system = runnableSoftware*
system = physicalNode* + commits* + cohesion


可運行的軟體是可以被重新配置而改變行為的
runnableSoftware = configure(config, runtimeDep, configurableSoftware)
configurableSoftware = install(physicalNode, installDep, installableSoftware)
installableSoftware = build(platform, buildDep, buildableSoftware)

而可建造的軟體是master分支的其中一個提交
commit on codebase = buildableSoftware(總之就是潛在的runnableSoftware)

(runtimeDeps, installDeps, buildDeps) are runnableSoftwares


runnableSoftware = commit + config + deploy(physicalNode)
runnableSoftware = (commit + config) + deploy(physicalNode)
runnableSoftware = commit + (config + deploy(physicalNode))
runnableSoftware = preconfig-commit + preconfig-physicalNode


__configure__ means modify the physical node setting, add or remove nodes.
__deploy__ means _install_ and _setup_ a tested software on node.
__release__ means change production software behavier includes update, rollback or reload setup.
__install__ means upload artifact to machine of node and unpack to destination directory, then do some necessary preprocess.
__setup__ means change behaiver or preforemance of software, that is designed to be changable properties.


## configure
部署Node所需要的資訊
1.Node的 PGP key
2.rootca的 PGP public key (用來簽證configer的PGP key)
3.通道url列表 (file, http, https, dnstxt)
4.基本配置 (例如可用資源限制, 但這不是必須的)

Node不需要開啟任何port,
也不需要暴露自己的IP(必要時可以用proxy來增加隱蔽性), 就可以配置自己
而整個流程也不一定需要中央伺服器, 可以是一個可修改的dns, 或是一個公有服務
Node所要做的只是開機後連線到一個已知的url並透過此網站來交換配置資訊
該url也可以是本地檔案, 這代表configer擁有上傳檔案到Node的手段
一旦Node可以bootstrap之後, 他所開啟的服務, 會將configer控制權大幅的擴張
安全性的關鍵在於configer的PGP key不能被竊取並破解

每個spot都有專屬目的資料夾, 即時同一份部署, 要安裝到多個spot也會安裝成多個資料夾
例如, 有3個spot都安裝某軟體的3個版本, 那總共會有9個目的地資料夾


## checkout

建造的前一個動作, 從版本庫取得特定的版本, 或是直接從url下載後解壓縮

noop的情形: 使用本地unpure資料夾

## build

noop的情形: 直接從checkout出來的目錄執行

## settle

佈置chroot過去的空間, 包含根目錄, 使用者, jail, namespace
額外磁區mounts
網路佈置

noop的情形: 不需要chroot的情形

## install

首先要settle space

安裝到 unpure 的資料夾
run之前, 如果該目的地資料夾的安裝與要求不同, 則會進行重新安裝, 或是使用之前的安裝
run途中, 如果plot的安裝改變了, 則service需要restart

要安裝的除了建造出來的軟體本身, 還包括runtime依賴

noop的情形: 直接從checkout出來的目錄執行


## setup

對 unpure 資料夾進行設定, 這個設定可以多次實行而不改變效果
設定也會蓋掉上一次的設定
run之前, 如果該目的地資料夾的設定與要求不同, 則會進行重新設定
run途中, 如果目的地資料夾的設定改變了, 則service需要reload

noop的情形: 完全使用預設setup, 或是完全沒有configfile的情形


## run

通常run之前會馬上進行setup
也早就已經透過install安裝所需依賴


## execute

與run的差別在於不能自訂要跑的command


## targets 各個操作的依賴關係

final -> setup -> install -> settle -> checkout?
                    |
                    v
          test ->  build -> checkout


### procedure(modules)
checkout: builtin+first
parse:    builtin
load:     builtin
settle:   builtin   checkout?
build:    exec      checkout
install:  builtin   checkout build settle
setup:    builtin   checkout build settle install
final:

### final target
@prod
run:      exec      checkout build settle install setup
module:   exec      checkout build settle install setup
prompt:
(prod-shell)

build

@test
test:     exec      checkout build [[settle install] setup]

@dev
shell:    builtin
execute:  exec
(dev-run)



checkout(url) -> sdir
paser(sdir/conf) -> pTABLE
load(pTABLE) -> lTABLE with ordered module execution
build(genrcfile(pTABLE)) -> cache/artifact with bTABLE

settle(pTABLE) -> sTABLE with root
install(pTABLE with root, artifact with bTABLE) -> iTABLE with installed_mark
setup(pTABLE with root) -> uTABLE with setup_mark

final(genrcfile(uTABLE with root))


proc            cond    hash                    vaild       make
--------------------------------------------------------------------
execute
final-rc        -       url|profile             rc+marks    genrcfile
  checkout      url     url|profile             -           fetch
  paser&load    -       -
  base
  fire-setup
    settle        m       sub(s, pTABLE)          rootmark    settle
    install       m       sub(i, pTABLE)+artifact installmark unpack
      fire-build       mins    sub(b, pTABLE)+source   artifact    fire build
        build-rc  mbui    sub(b, pTABLE)          rc          genrcfile
    setup         m       sub(u, pTABLE)          setupmark   setup
  post



2019最終決定版
------------

load+ = parse(checkout) + load(depend module) + base

fire@run|#fire@module|fire@prod-shell
    load+
    fire@bulid
        load+
        package
        postload
    fire@setup
        load+
        settle
        install
        post-setup
        postload
    reload+

fire@test
    load+
    fire@bulid
        load+
    postload

fire@shell|fire@termainal|fire@execute
    load+
    postload





## pm spot

STOPPED - startCmd  -> SCHE_START - dependOk -> STARTING - sync_or_condition
                    -> RUNNING

condition:
- pid file found
- wait a little time, process still exist

SCHE_START.dependExistFail -> STOPPED
STARTING.conditionFail -> STARTING_FAIL
STARTING_FAIL.timeout -> STOPPED

RUNNING - stopCmd -> SCHE_STOP - dependQuit -> STOPPING - sync -> STOPPED

RUNNING.processGone -> FAIL
FAIL.timeout -> STOPPED


## 其他資源

Install @ Root
Setup @ Root
Volume (Root) @ Root
Network

其他資源跟行程服務並無差異
都是透過pm invoke來發起
差別在於pm main並不檢查pid, 而是使用execCheck來確定資源是否還存在


## enve makepkg
use fakeroot to make tar file


## enve store

這個store是install的預設目標路徑
主要是提供cache性質般的儲存方式

使用者必須提供 1.需求文本(作為快取用) 2.確認過期(不是必須的)
            3.重現方法(不是必須的) 4.catalog=any
            5.user=$USER 6.title=none 7.保密性private=


有時候1與3是相同的東西

首先根據文版算出快取$hash
接下來搜尋路徑 $STORE/($user|root)[-private]-$catalog[-{0,1,2,3}]/$hash-$title
如果有找到則回傳, 否則
找到持有寫入權限的資料夾 $STORE/[$user-]$catalog[-{0,1,2,3}]
沒有的話根據$private建立一個自己的快取資料夾, 再來
建立目的資料夾, 執行製作方法並把環境變數OUT設定為該目的資料夾

比起nix-store有以下不同的特性
1.ownership不限於root(因此非root用戶也可以進行安裝)
2.可以內含setuid的執行檔
3.檔案預設是readonly, 但是資料夾預設不是readonly
4.不一定使用固定的檔案時間戳記
5.不一定採用資料夾內容的hash來作為項目的名稱, 也可能採用其他內文的hash
6.盡量不使用symlink, 如果要有dependency的概念, 使用文字檔取代symlink
7.不一定是immutable的


## pm mount

mount bind
mount tmp
(X)mount loop



## pm subroot

建立可以被chroot的資料夾




## pm 與 enve

pm會對以root的設定來對firechain中的install與setup拆分出另外的service

software-v1.0!build <-
  !install@$root.service|cachedir <-
    !setup@$root.service <-
      !run@$root.service

請注意setup是排斥的, 可以多個版本install到同一個root,
但是不能多個版本setup到同一個root

如果要setup多個版本多個實體, 有幾的方法

1. 分隔root
2. 使用獨立的config設定

例如:

    software-v1.0!setup@$cfgpath1@$root.service <-
      software-v1.0!run@$cfgpath1@$root.service

    software-v1.0!setup@$cfgpath2@$root.service <-
      software-v1.0!run@$cfgpath2@$root.service

不使用獨立root的情形, 要確保同一個root中的各個setup不會產生衝突

build的結果只會存放在cache, 所以與root無關

install 與 root 可以同時存在或是無關(因為安裝在cache, nix), 而且Idempotence
insA -> insB -> insB  == insA + insB
setup 與 root 不能同時存在, 但也是Idempotence
setA -> setB -> setB  == setB



## pm 無狀態

文本監視者 --發送新部署--> 部署狀態持有者 --差異命令流--> pm狀態機
pm的狀態保存在文件系統和作業系統之中


## pm 狀態結構

PMHOME=/var/opt/pm

$PMHOME/jobs/$JOBID/parameter - 發起前寫入, 發動的參數與理由, table格式, debug用
$PMHOME/jobs/$JOBID/pid - 發起成功後寫入
$PMHOME/jobs/$JOBID/retcode - 結束後寫入

$PMHOME/units/$UNITID/parameter - UNIT的設定值, 可以被更動
$PMHOME/units/$UNITID/state - 當時的fsm狀態

$PMHOME/input - input fifo


## fatal of pm (當機)

pm 會記錄所有衍生的子行程, 一但當機, 監視行程會消滅所有子行程
然後監視行程再退出

## pm terminal (main模式之一)

打開一個代表pm的terminal並且打開預設shell
監視行稱會監視該shell有沒有退出
某些服務可以掛在tmux底下, 可以打新的terminal來連結到某個服務

pm shell <---> enve shell
一個整合式的開發環境


## pm dispatch

根據來源資訊, 設定各個pm的資源
因此pm可以單純化為接受輸入的狀態機

可以在dispatch期間融合spot和firechain的內容

pm dispatch 的特化版本還可以偵測兩個版本的變化(diff)來發出指令




## pm inventory

inventory 儲存著各個remote, 每個remote的特色就是有/var/pm/default.pipe
pm 可以一次列出所有遠端機器的資源狀態
並且可以利用 remote.pm1.pm2.pm3.serviceA 的方式來參照各個資源

inventory 可以是遠端也可以是localdir


## pm client

發送命令到name pipe之後, 監視pm server的進度
一邊回報相關的進度, 等達到完成點後, 設定retcode後退出

start|stop|reload|restart
try-restart             only if running
reload-or-restart
try-reload-or-restart
cat                     show property
set-property
reset-failed
list-dependencies

(X) pm client 與 pm dispatch 是同類型功能的不同機制

pm client ---> pm dispatch ---> pm.socket (pm fsm) ---> pm launch


## pm inovke




## pm syssrv

pm 可以自我部署到系統中來進行首次的boostrap
這讓更上層的作業系統可以自動喚起pm

計畫可以支援的平台有
- cygrunsrv
- systemd
- BSD-style init(8)
- launchd
- pm (非自動偵測)

除了pm host本身以外其他平台只能註冊一個pm service
因此如果需要多個pm service必須以一個pm host當主機
系統級的pm以root權限啟動, 如果要隔離namespace, 則在pm slave中進行隔離


支援的動作有
host install --force --init-stream XXX --stdout YYY --as-root
host remove
host start
host stop

pm boot 之後需要初始的命令流, 否則整個pm會不含任何service而陷入被動模式

這個部署很簡單, 就是把特定檔案放置到系統中的位置.


## pm sub (main模式之一)(遞迴)

pm 本身也是一個可部署的行程, 支援所有pm invoke協定
特別的地方是, parent-pm 知道 sub-pm 的 socket, 所以可以對 sub-pm 單向命令
也由於知道 sub-pm 的 PM_ROOT 還有完整的檔案系統root, 所以可以取得 sub-pm 的內部狀態


隔離假設, 切換到nobody使用者之後chroot
需要使用root來執行這些程式碼, 因此pm不能在非末端userpm的情況下遞迴

rootpm|chroot_rootpm -> rootpm|jail_rootpm|chroot_rootpm|chroot_userpm|userpm
jail_rootpm -> jail_rootpm|chroot_rootpm|chroot_userpm|userpm
userpm|chroot_userpm|jail_userpm -> userpm

簡單來說由於U不能接續R, 所以
(O) RU, RRU, RRRR, UUUU, RRUU
(X) UR, RUR, RURR, URRR


rootpm|jailrootpm -> jailrootpm 需要特殊工具
rootpm|jailrootpm -> chrootpm 只需要 chpd

## pm attach

連接mount資源的方式?


## configure loader (pm main)
--init-stream 通常會設定一個 configure loader service 掛在pm底下

幾種基本的 cfg loader

- 從特定檔案
- 從特定網址
- 接收特定軟體的遠端指令 (ex: k8s)

cfg loader會獲得指令後傳送給上層的pm master


# enve rtmux
remote tmux

兩端都要安裝enve, 兩端要設定sshkey, 伺服端要初始化與掛載pm - rtmux

每個enve server中的每個使用者都有一個專屬的tmux socket
每個enve server都有一個專屬的sshd
這個enve server可以用pm掛載服務, 並且hook入pm的發射執行系統

sshd之中有設定ForceCommand, 來確保連線進入的初始環境
客戶端透過 rtmux(ssh+tmux) 來進行連線

rtmux_URL format:
    URL: ${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_PORT}/${REMOTE_ENVE}
    REMOTE_ENVE: REMOTE_ENVE_URL | REMOTE_ENVE_NAME
每個部分都可以省略, 預設值會從環境變數中提取
REMOTE_ENVE_URL=$(eval echo \$REMOTE_ENVE_URL_$REMOTE_ENVE_NAME)


兩種模式run模式或是attached shell模式
rtmux [option] rtmux_URL command...  這與一般的ssh連線完全相圖
rtmux [option] rtmux_URL -t session

rtmux [option] rtmux_URL ls-session

(X-直接利用tmux能力)利用kitty開分頁的能力, 一次連結所有的session
(X)rtmux [option] url attach-all

傳送本地或雲端enve到遠端執行的能力, 遠端會自動加入remote的role
rtmux [option] rtmux_URL -f enve_url

在attached shell模式, 即使斷線也會繼續執行程式, 之後可以重新連線

pm的關機能力會先發送SIGHUB給所有的session, 3秒之後再依照常規關機

/Applications/kitty.app/Contents/MacOS/kitty +kitten ssh -p 2022 -t localhost bash -l -c 'tmux -2u new enve /Users/pengweiqi/googlesync/sync2017/doc-linux2015/devon/devon_bash/example/zsh.enve.ini shell'



# Automated provisioning using apkovl

This can be done by specifying apkovl= in the kernel command line


# [不該在這裡的章節] wrapped enve

parent enve依賴 child enve, 但其實是 parent 是要改變或設定 child

# [不該在這裡的章節] enve handler

中介處理並轉換enve的enve

# [不該在這裡的章節] machm ovl

ovl 是系統部署方式
ovl 是一個tar檔案, 內部含有/etc等等設定檔, 會在開機initramfs時覆蓋root
ovl 可以是openssl 加密的 base64 的 zlib 壓縮的 tar檔案
ovl 可以是一個url, initramfs會掛載網路, 並且嘗試下載
tar內可以有 /layers 資料夾裡面的子資料夾如下格式
$NN-$favor1[-$favor2...], 一旦所有的favor都符合, 將會$NN順序套用到root中
有以下幾種favor可用
MAC_ADDRESS     /sys/class/net/$device/address
MACHINE_UUID    /sys/class/dmi/id/product_uuid
VOLUME_UUID
KERNAL          $(uname -s)
KERNAL_RELEASE  $(uname -r)

因此一個檔案就可以包含各種不同作業系統與版本全部機器的設定檔, 可以一次完成上傳
而且由於是base64加密文字格式, 很容易上傳到github-gist之類的公開場所

在linux中 root 必須是 btrfs 否則必須施加overlayfs
在bsd中 root 必須是 zfs


每次開機initramfs時, 會設定overlay, 關機後overlay會被自動刪除
因此系統總是自動部署, 自動還原

ovl 除了放在公開網路上, 也能放在分區中特定的位置, ex: btrfs:/@ovls/$ovl
ovl 內可以含有機器的金鑰, 這很重要


# [不該在這裡的章節] machm mksys

新安裝作業系統在特定的磁區, 並且設定grub.cfg
可以設定定期安裝, 例如每兩週安裝一次, 一但重開機就會自動轉換到新的kernal
一但發生問題也能透過grub.cfg的開機選單來還原

必須有efi磁區裡面安裝grub, 開機方式可以是gpt+bios或是gpt+efi
在linux中 root 必須是 btrfs 否則必須施加overlayfs
在bsd中 root 必須是 zfs

安裝的系統必須支援ovl





1. 各專案互相獨立不影響, 所有的全域系統設定都應該是*唯讀*的
2. 所有與專案有關的事物都應該集中在*一個*專案資料夾, 包含開發用的各種編輯器或工具的設定檔
3. 不論專案中有多少種程式語言, 都應該集中在*一個*專案資料夾
4. 不管任何開發平台, 開發\建造\測試\發佈的指令只會有*一種*方式
5. 不管任何開發平台, 安裝環境與清除環境只需要*一鍵*
6. 不管多少種發佈檔(語言,平台), 只會有*一個*版本庫
7. 模組化的安裝工具, 開發環境, 與依賴


1. 隔離性: 可以在一個雜亂的作業系統中展開, 而不影響其他專案.
2. 完整性: 可以在一個空白的作業系統中展開.
3. 整合性: 子專案?
4. 統一性: 統一工具指令但是開放編輯器與流程
5. 方便性: 快速安裝
6. 單一性: 單一版本庫
7. 模組化: (尚未計畫)



軟體開發之建置風險的故事[http://rocksaying.tw/archives/11157957.html]
=========================================
開發環境的建置風險
測試平台的建置風險
套件相依性的建置風險
部署程序的建置風險

